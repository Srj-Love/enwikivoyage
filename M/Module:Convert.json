["-- Convert a value from one unit of measurement to another.\n-- Example: ",{"type":"{{","value":[["convert"],["123"],["lb"],["kg"]]}," --> 123 pounds (56 kg)\n\nlocal MINUS = '−'  -- Unicode U+2212 MINUS SIGN (UTF-8: e2 88 92)\nlocal abs = math.abs\nlocal floor = math.floor\nlocal format = string.format\nlocal log10 = math.log10\nlocal ustring = mw.ustring\nlocal ulen = ustring.len\nlocal usub = ustring.sub\n\n-- Configuration options to keep magic values in one location.\n-- Conversion data and message text are defined in separate modules.\nlocal config, maxsigfig\nlocal numdot, numsep  -- each must be a single byte for simple regex search\/replace\nlocal default_exceptions, link_exceptions, all_units\nlocal text_code\nlocal varname        -- can be a code to use variable names that depend on value\nlocal from_en_table  -- to translate an output string of en digits to local language\nlocal to_en_table    -- to translate an input string of digits in local language to en\n-- Use translation_table in convert\/text to change the following.\nlocal group_method = 3     -- code for how many digits are in a group\nlocal per_word = 'per'     -- for units like \"miles per gallon\"\nlocal plural_suffix = 's'  -- only other useful value is probably '' to disable plural unit names\n\n-- All units should be defined in the data module. However, to cater for quick changes\n-- and experiments, any unknown unit is looked up in an extra data module, if it exists.\n-- That module would be transcluded in only a small number of pages, so there should be\n-- little server overhead from making changes, and changes should propagate quickly.\nlocal extra_module  -- name of module with extra units\nlocal extra_units   -- nil or table of extra units from extra_module\n\nlocal function boolean(text)\n\t-- Return true if text represents a \"true\" option value.\n\tif text then\n\t\ttext = text:lower()\n\t\tif text == 'on' or text == 'yes' then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n\nlocal function from_en(text)\n\t-- Input is a string representing a number in en digits with '.' decimal mark,\n\t-- without digit grouping (which is done just after calling this).\n\t-- Return the translation of the string with numdot and digits in local language.\n\tif numdot ~= '.' then\n\t\ttext = text:gsub('%.', numdot)\n\tend\n\tif from_en_table then\n\t\ttext = text:gsub('%d', from_en_table)\n\tend\n\treturn text\nend\n\nlocal function to_en(text)\n\t-- Input is a string representing a number in the local language with\n\t-- an optional numdot decimal mark and numsep digit grouping.\n\t-- Return the translation of the string with '.' mark and en digits,\n\t-- and no separators (they have to be removed here to handle cases like\n\t-- numsep = '.' and numdot = ',' with input \"1.234.567,8\").\n\tif numsep ~= '' then\n\t\ttext = text:gsub('[' .. numsep .. ']', '')  -- use '[x]' in case x is '.'\n\tend\n\tif numdot ~= '.' then\n\t\ttext = text:gsub('[' .. numdot .. ']', '.')\n\tend\n\tif to_en_table then\n\t\ttext = ustring.gsub(text, '%d', to_en_table)\n\tend\n\treturn text\nend\n\nlocal spell_module  -- name of module that can spell numbers\nlocal speller       -- function from that module to handle spelling (set if spelling is wanted)\n\nlocal function set_config(frame)\n\t-- Set configuration options from template #invoke or defaults.\n\tconfig = frame.args\n\tnumdot = config.numdot or '.'       -- decimal mark before fractional digits\n\tnumsep = config.numsep or ','       -- group separator for numbers (',', '.', '')\n\tmaxsigfig = config.maxsigfig or 14  -- maximum number of significant figures\n\t-- Scribunto sets the global variable 'mw'.\n\t-- A testing program can set the global variable 'is_test_run'.\n\tlocal data_module, text_module, data_code\n\tif is_test_run then\n\t\tlocal langcode = mw.language.getContentLanguage().code\n\t\tdata_module = \"convertdata-\" .. langcode\n\t\ttext_module = \"converttext-\" .. langcode\n\t\textra_module = \"convertextra-\" .. langcode\n\t\tspell_module = \"ConvertNumeric\"\n\telse\n\t\tlocal sandbox = boolean(config.sandbox) and '\/sandbox' or ''\n\t\tdata_module = \"Module:Convert\/data\" .. sandbox\n\t\ttext_module = \"Module:Convert\/text\" .. sandbox\n\t\textra_module = \"Module:Convert\/extra\" .. sandbox\n\t\tspell_module = \"Module:ConvertNumeric\"\n\tend\n\tdata_code = mw.loadData(data_module)\n\ttext_code = mw.loadData(text_module)\n\tdefault_exceptions = data_code.default_exceptions\n\tlink_exceptions = data_code.link_exceptions\n\tall_units = data_code.all_units\n\tlocal translation = text_code.translation_table\n\tif translation then\n\t\tif translation.group then\n\t\t\tgroup_method = translation.group\n\t\tend\n\t\tif translation.per_word then\n\t\t\tper_word = translation.per_word\n\t\tend\n\t\tif translation.plural_suffix then\n\t\t\tplural_suffix = translation.plural_suffix\n\t\tend\n\t\tvarname = translation.varname\n\t\tfrom_en_table = translation.from_en\n\t\tlocal use_workaround = true\n\t\tif use_workaround then\n\t\t\t-- 2013-07-05 workaround bug by making a copy of the required table.\n\t\t\t-- mw.ustring.gsub fails with a table (to_en_table) as the replacement,\n\t\t\t-- if the table is accessed via mw.loadData.\n\t\t\tlocal source = translation.to_en\n\t\t\tif source then\n\t\t\t\tto_en_table = {}\n\t\t\t\tfor k, v in pairs(source) do\n\t\t\t\t\tto_en_table[k] = v\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tto_en_table = translation.to_en\n\t\tend\n\tend\nend\n\nlocal function collection()\n\t-- Return a table to hold items.\n\treturn {\n\t\tn = 0,\n\t\tadd = function (self, item)\n\t\t\tself.n = self.n + 1\n\t\t\tself[self.n] = item\n\t\tend,\n\t}\nend\n\nlocal function divide(numerator, denominator)\n\t-- Return integers quotient, remainder resulting from dividing the two\n\t-- given numbers, which should be unsigned integers.\n\tlocal quotient, remainder = floor(numerator \/ denominator), numerator % denominator\n\tif not (0 <= remainder and remainder < denominator) then\n\t\t-- Floating point limits may need this, as in ",{"type":"{{","value":[["convert"],["160.02"],["Ym"],["ydftin"]]},".\n\t\tremainder = 0\n\tend\n\treturn quotient, remainder\nend\n\nlocal function split(text, delimiter)\n\t-- Return a numbered table with fields from splitting text.\n\t-- The delimiter is used in a regex without escaping (for example, '.' would fail).\n\t-- Each field has any leading\/trailing whitespace removed.\n\tlocal t = {}\n\ttext = text .. delimiter  -- to get last item\n\tfor item in text:gmatch('%s*(.-)%s*' .. delimiter) do\n\t\ttable.insert(t, item)\n\tend\n\treturn t\nend\n\nlocal function strip(text)\n\t-- If text is a string, return its content with no leading\/trailing\n\t-- whitespace. Otherwise return nil (a nil argument gives a nil result).\n\tif type(text) == 'string' then\n\t\treturn text:match(\"^%s*(.-)%s*$\")\n\tend\nend\n\nlocal function wanted_category(cat)\n\t-- Return cat if it is wanted in current namespace, otherwise return nil.\n\t-- This is so tracking categories only include pages that need correction.\n\tlocal title = mw.title.getCurrentTitle()\n\tif title then\n\t\tlocal nsdefault = '0'  -- default namespace: '0' = article; '0,10' = article and template\n\t\tlocal namespace = title.namespace\n\t\tfor _, v in ipairs(split(config.nscat or nsdefault, ',')) do\n\t\t\tif namespace == tonumber(v) then\n\t\t\t\treturn cat\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal function message(mcode)\n\t-- Return wikitext for an error message, including category if specified\n\t-- for the message type.\n\t-- mcode = numbered table specifying the message:\n\t--    mcode[1] = 'cvt_xxx' (string used as a key to get message info)\n\t--    mcode[2] = 'parm1' (string to replace first %s if any in message)\n\t--    mcode[3] = 'parm2' (string to replace second %s if any in message)\n\t--    mcode[4] = 'parm3' (string to replace third %s if any in message)\n\tlocal msg = text_code.all_messages[mcode[1]]\n\tlocal nowiki = mw.text.nowiki\n\tif msg then\n\t\tlocal parts = {}\n\t\tlocal regex, replace = msg.regex, msg.replace\n\t\tfor i = 1, 3 do\n\t\t\tlocal limit = 40\n\t\t\tlocal s = mcode[i + 1]\n\t\t\tif s then\n\t\t\t\tif regex and replace then\n\t\t\t\t\ts = s:gsub(regex, replace)\n\t\t\t\t\tlimit = nil  -- allow long \"should be\" messages\n\t\t\t\tend\n\t\t\t\t-- Escape user input so it does not break the message.\n\t\t\t\t-- To avoid reference tags (like ",{"type":"{{","value":[["convert"],["1",{"type":"<","value":["ref",["xyz"]]}],["m"]]},") or other tags\n\t\t\t\t-- breaking the mouseover title, any strip marker starting with char(127) is\n\t\t\t\t-- replaced with escaped '",{"type":"<","value":["ref",["..."]]},"' or '...' (text not needing i18n).\n\t\t\t\tlocal append = ''\n\t\t\t\tlocal pos = s:find(string.char(127), 1, true)\n\t\t\t\tif pos then\n\t\t\t\t\tif s:find('-ref-', 1, true) then\n\t\t\t\t\t\tappend = '<ref>...<\/ref>'\n\t\t\t\t\telse\n\t\t\t\t\t\tappend = '...'\n\t\t\t\t\tend\n\t\t\t\t\ts = s:sub(1, pos - 1)\n\t\t\t\tend\n\t\t\t\tif limit and ulen(s) > limit then\n\t\t\t\t\ts = usub(s, 1, limit)\n\t\t\t\t\tif append == '' then\n\t\t\t\t\t\tappend = '...'\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\ts = nowiki(s) .. append\n\t\t\telse\n\t\t\t\ts = '?'\n\t\t\tend\n\t\t\tparts[i] = s\n\t\tend\n\t\tlocal title = format(msg[1] or 'Missing message', parts[1], parts[2], parts[3])\n\t\tlocal text = msg[2] or 'Missing message'\n\t\tlocal cat = wanted_category(text_code.all_categories[msg[3]]) or ''\n\t\tlocal anchor = msg[4] or ''\n\t\tlocal fmt = text_code.all_messages['cvt_format'] or 'convert: bug'\n\t\ttitle = title:gsub('\"', '\"')\n\t\treturn format(fmt, anchor, title, text, cat)\n\tend\n\treturn 'Convert internal error: unknown message'\nend\n\nlocal function add_warning(parms, level, mcode, text)\n\t-- If enabled, add a warning that will be displayed after the convert result.\n\t-- To reduce output noise, only the first warning is displayed.\n\tif config.warnings then\n\t\tif level <= (tonumber(config.warnings) or 1) then\n\t\t\tif parms.warnings == nil then\n\t\t\t\tparms.warnings = message({ mcode, text })\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal function spell_number(parms, inout, number, numerator, denominator)\n\t-- Return result of spelling (number, numerator, denominator), or\n\t-- return nil if spelling is not available or not supported for given text.\n\t-- Examples (each value must be a string or nil):\n\t--   number  numerator  denominator  output\n\t--   ------  ---------  -----------  -------------------\n\t--   \"1.23\"    nil        nil        one point two three\n\t--    \"1\"      \"2\"        \"3\"        one and two thirds\n\t--    nil      \"2\"        \"3\"        two thirds\n\tif not speller then\n\t\tlocal function get_speller(module)\n\t\t\treturn require(module).spell_number\n\t\tend\n\t\tlocal success\n\t\tsuccess, speller = pcall(get_speller, spell_module)\n\t\tif not success or type(speller) ~= 'function' then\n\t\t\tadd_warning(parms, 1, 'cvt_no_spell')\n\t\t\treturn nil\n\t\tend\n\tend\n\tlocal case\n\tif parms.spell_upper == inout then\n\t\tcase = true\n\t\tparms.spell_upper = nil  -- only uppercase first word in a multiple unit\n\tend\n\tlocal sp = not parms.opt_sp_us\n\tlocal adj = parms.opt_adjectival\n\treturn speller(number, numerator, denominator, case, sp, adj)\nend\n\n------------------------------------------------------------------------\n-- BEGIN: Code required only for built-in units.\n-- LATER: If need much more code, move to another module to simplify this module.\nlocal function speed_of_sound(altitude)\n\t-- This is for the Mach built-in unit of speed.\n\t-- Return speed of sound in metres per second at given altitude in feet.\n\t-- If no altitude given, use default (zero altitude = sea level).\n\t-- Table gives speed of sound in miles per hour at various altitudes:\n\t--   altitude = -17,499 to 302,499 feet\n\t-- mach_table[a + 4] = s where\n\t--   a = (altitude \/ 5000) rounded to nearest integer (-3 to 60)\n\t--   s = speed of sound (mph) at that altitude\n\t-- LATER: Should calculate result from an interpolation between the next\n\t-- lower and higher altitudes in table, rather than rounding to nearest.\n\t-- From: http:\/\/www.aerospaceweb.org\/question\/atmosphere\/q0112.shtml\n\tlocal mach_table = {                                                       -- a =\n\t\t799.5, 787.0, 774.2, 761.207051,                                       -- -3 to  0\n\t\t748.0, 734.6, 721.0, 707.0, 692.8, 678.3, 663.5, 660.1, 660.1, 660.1,  --  1 to 10\n\t\t660.1, 660.1, 660.1, 662.0, 664.3, 666.5, 668.9, 671.1, 673.4, 675.6,  -- 11 to 20\n\t\t677.9, 683.7, 689.9, 696.0, 702.1, 708.1, 714.0, 719.9, 725.8, 731.6,  -- 21 to 30\n\t\t737.3, 737.7, 737.7, 736.2, 730.5, 724.6, 718.8, 712.9, 707.0, 701.1,  -- 31 to 40\n\t\t695.0, 688.9, 682.8, 676.6, 670.4, 664.1, 657.8, 652.9, 648.3, 643.7,  -- 41 to 50\n\t\t639.1, 634.4, 629.6, 624.8, 620.0, 615.2, 613.2, 613.2, 613.2, 613.5,  -- 51 to 60\n\t}\n\taltitude = altitude or 0\n\tlocal a = (altitude < 0) and -altitude or altitude\n\ta = floor(a \/ 5000 + 0.5)\n\tif altitude < 0 then\n\t\ta = -a\n\tend\n\tif a < -3 then\n\t\ta = -3\n\telseif a > 60 then\n\t\ta = 60\n\tend\n\treturn mach_table[a + 4] * 0.44704  -- mph converted to m\/s\nend\n-- END: Code required only for built-in units.\n------------------------------------------------------------------------\n\nlocal function check_mismatch(unit1, unit2)\n\t-- If unit1 cannot be converted to unit2, return an error message table.\n\t-- This allows conversion between units of the same type, and between\n\t-- Nm (normally torque) and ftlb (energy), as in gun-related articles.\n\t-- This works because Nm is the base unit (scale = 1) for both the\n\t-- primary type (torque), and the alternate type (energy, where Nm = J).\n\t-- A match occurs if the primary types are the same, or if unit1 matches\n\t-- the alternate type of unit2, and vice versa. That provides a whitelist\n\t-- of which conversions are permitted between normally incompatible types.\n\tif unit1.utype == unit2.utype or\n\t\t(unit1.utype == unit2.alttype and unit1.alttype == unit2.utype) then\n\t\treturn nil\n\tend\n\treturn { 'cvt_mismatch', unit1.utype, unit2.utype }\nend\n\nlocal function override_from(out_table, in_table, fields)\n\t-- Copy the specified fields from in_table to out_table, but do not\n\t-- copy nil fields (keep any corresponding field in out_table).\n\tfor _, field in ipairs(fields) do\n\t\tif in_table[field] then\n\t\t\tout_table[field] = in_table[field]\n\t\tend\n\tend\nend\n\nlocal function shallow_copy(t)\n\t-- Return a shallow copy of table t.\n\t-- Do not need the features and overhead of the Scribunto mw.clone().\n\tlocal result = {}\n\tfor k, v in pairs(t) do\n\t\tresult[k] = v\n\tend\n\treturn result\nend\n\nlocal unit_mt = {\n\t-- Metatable to get missing values for a unit that does not accept SI prefixes,\n\t-- or for a unit that accepts prefixes but where no prefix was used.\n\t-- In the latter case, and before use, fields symbol, name1, name1_us\n\t-- must be set from _symbol, _name1, _name1_us respectively.\n\t-- Warning: The boolean value 'false' is returned for any missing field\n\t-- so __index is not called twice for the same field in a given unit.\n\t__index = function (self, key)\n\t\tlocal value\n\t\tif key == 'name1' or key == 'sym_us' then\n\t\t\tvalue = self.symbol\n\t\telseif key == 'name2' then\n\t\t\tvalue = self.name1 .. plural_suffix\n\t\telseif key == 'name1_us' then\n\t\t\tvalue = self.name1\n\t\t\tif not rawget(self, 'name2_us') then\n\t\t\t\t-- If name1_us is 'foot', do not make name2_us by appending plural_suffix.\n\t\t\t\tself.name2_us = self.name2\n\t\t\tend\n\t\telseif key == 'name2_us' then\n\t\t\tlocal raw1_us = rawget(self, 'name1_us')\n\t\t\tif raw1_us then\n\t\t\t\tvalue = raw1_us .. plural_suffix\n\t\t\telse\n\t\t\t\tvalue = self.name2\n\t\t\tend\n\t\telseif key == 'link' then\n\t\t\tvalue = self.name1\n\t\telse\n\t\t\tvalue = false\n\t\tend\n\t\trawset(self, key, value)\n\t\treturn value\n\tend\n}\n\nlocal unit_prefixed_mt = {\n\t-- Metatable to get missing values for a unit that accepts SI prefixes,\n\t-- and where a prefix has been used.\n\t-- Before use, fields si_name, si_prefix must be defined.\n\t__index = function (self, key)\n\t\tlocal value\n\t\tif key == 'symbol' then\n\t\t\tvalue = self.si_prefix .. self._symbol\n\t\telseif key == 'sym_us' then\n\t\t\tvalue = self.symbol  -- always the same as sym_us for prefixed units\n\t\telseif key == 'name1' then\n\t\t\t-- prefix_position is a byte (not character) position, so use Lua's sub().\n\t\t\tlocal pos = rawget(self, 'prefix_position') or 1\n\t\t\tvalue = self._name1\n\t\t\tvalue = value:sub(1, pos - 1) .. self.si_name .. value:sub(pos)\n\t\telseif key == 'name2' then\n\t\t\tvalue = self.name1 .. plural_suffix\n\t\telseif key == 'name1_us' then\n\t\t\tvalue = rawget(self, '_name1_us')\n\t\t\tif value then\n\t\t\t\tlocal pos = rawget(self, 'prefix_position') or 1\n\t\t\t\tvalue = value:sub(1, pos - 1) .. self.si_name .. value:sub(pos)\n\t\t\telse\n\t\t\t\tvalue = self.name1\n\t\t\tend\n\t\telseif key == 'name2_us' then\n\t\t\tif rawget(self, '_name1_us') then\n\t\t\t\tvalue = self.name1_us .. plural_suffix\n\t\t\telse\n\t\t\t\tvalue = self.name2\n\t\t\tend\n\t\telseif key == 'link' then\n\t\t\tvalue = self.name1\n\t\telse\n\t\t\tvalue = false\n\t\tend\n\t\trawset(self, key, value)\n\t\treturn value\n\tend\n}\n\nlocal unit_per_mt = {\n\t-- Metatable to get values for a \"per\" unit of form \"x\/y\".\n\t-- This is never called to determine a unit name or link because \"per\" units\n\t-- are handled as a special case.\n\t__index = function (self, key)\n\t\tlocal value\n\t\tif key == 'symbol' then\n\t\t\tlocal per = self.per\n\t\t\tlocal unit1, unit2 = per[1], per[2]\n\t\t\tif unit1 then\n\t\t\t\tvalue = unit1[key] .. '\/' .. unit2[key]\n\t\t\telse\n\t\t\t\tvalue = '\/' .. unit2[key]\n\t\t\tend\n\t\telseif key == 'sym_us' then\n\t\t\tvalue = self.symbol\n\t\telseif key == 'scale' then\n\t\t\tlocal per = self.per\n\t\t\tlocal unit1, unit2 = per[1], per[2]\n\t\t\tvalue = (unit1 and unit1.scale or 1) * self.scalemultiplier \/ unit2.scale\n\t\telse\n\t\t\tvalue = false\n\t\tend\n\t\trawset(self, key, value)\n\t\treturn value\n\tend\n}\n\nlocal function lookup(unitcode, opt_sp_us, what, utable, fails, depth)\n\t-- Return true, t where t is a copy of the unit's converter table,\n\t-- or return false, t where t is an error message table.\n\t-- Parameter opt_sp_us is true for US spelling of SI prefixes and\n\t-- the symbol and name of the unit. If true, the result includes field\n\t-- sp_us = true (that field may also have been in the unit definition).\n\t-- Parameter 'what' determines whether combination units are accepted:\n\t--   'no_combination'  : single unit only\n\t--   'any_combination' : single unit or combination or output multiple\n\t--   'only_multiple'   : single unit or output multiple only\n\t-- Parameter unitcode is a symbol (like 'g'), with an optional SI prefix (like 'kg').\n\t-- If, for example, 'kg' is in this table, that entry is used;\n\t-- otherwise the prefix ('k') is applied to the base unit ('g').\n\t-- If unitcode is a known combination code (and if allowed by what),\n\t-- a table of output multiple unit tables is included in the result.\n\t-- For compatibility with the old template, an underscore in a unitcode is\n\t-- replaced with a space so usage like ",{"type":"{{","value":[["convert"],["350"],["board_feet"]]}," works.\n\t-- Wikignomes may also put two spaces or \" \" in combinations, so\n\t-- replace underscore, \" \", and multiple spaces with a single space.\n\tutable = utable or all_units\n\tfails = fails or {}\n\tdepth = depth and depth + 1 or 1\n\tif depth > 9 then\n\t\t-- There are ways to mistakenly define units which result in infinite\n\t\t-- recursion when lookup() is called. That gives a long delay and very\n\t\t-- confusing error messages, so the depth parameter is used as a guard.\n\t\treturn false, { 'cvt_lookup', unitcode }\n\tend\n\tif unitcode == nil or unitcode == '' then\n\t\treturn false, { 'cvt_no_unit' }\n\tend\n\tunitcode = unitcode:gsub('_', ' '):gsub(' ', ' '):gsub('  +', ' ')\n\tlocal t = utable[unitcode]\n\tif t then\n\t\tif t.shouldbe then\n\t\t\treturn false, { 'cvt_should_be', t.shouldbe }\n\t\tend\n\t\tlocal force_sp_us = opt_sp_us\n\t\tif t.sp_us then\n\t\t\tforce_sp_us = true\n\t\t\topt_sp_us = true\n\t\tend\n\t\tlocal target = t.target  -- nil, or unitcode is an alias for this target\n\t\tif target then\n\t\t\tlocal success, result = lookup(target, opt_sp_us, what, utable, fails, depth)\n\t\t\tif not success then return false, result end\n\t\t\toverride_from(result, t, { 'customary', 'default', 'link', 'symbol', 'symlink' })\n\t\t\tlocal multiplier = t.multiplier\n\t\t\tif multiplier then\n\t\t\t\tresult.multiplier = tostring(multiplier)\n\t\t\t\tresult.scale = result.scale * multiplier\n\t\t\tend\n\t\t\treturn true, result\n\t\tend\n\t\tlocal per = t.per  -- nil\/false, or a numbered table for \"x\/y\" units\n\t\tif per then\n\t\t\tlocal result = { utype = t.utype, per = {} }\n\t\t\tresult.scalemultiplier = t.multiplier or 1\n\t\t\toverride_from(result, t, { 'invert', 'iscomplex', 'default', 'link', 'symbol', 'symlink' })\n\t\t\tresult.symbol_raw = (result.symbol or false)  -- to distinguish between a defined exception and a metatable calculation\n\t\t\tlocal cvt = result.per\n\t\t\tlocal prefix\n\t\t\tfor i, v in ipairs(per) do\n\t\t\t\tif i == 1 and text_code.currency[v] then\n\t\t\t\t\tprefix = v\n\t\t\t\telse\n\t\t\t\t\tlocal success, t = lookup(v, opt_sp_us, 'no_combination', utable, fails, depth)\n\t\t\t\t\tif not success then return false, t end\n\t\t\t\t\tcvt[i] = t\n\t\t\t\t\tif t.sp_us then  -- if the top or bottom unit forces sp=us, set the per unit to use the correct name\/symbol\n\t\t\t\t\t\tforce_sp_us = true\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tif prefix then\n\t\t\t\tresult.vprefix = prefix\n\t\t\telse\n\t\t\t\tresult.vprefix = false  -- to avoid calling __index\n\t\t\tend\n\t\t\tresult.sp_us = force_sp_us\n\t\t\treturn true, setmetatable(result, unit_per_mt)\n\t\tend\n\t\tlocal combo = t.combination  -- nil or a table of unitcodes\n\t\tif combo then\n\t\t\tlocal multiple = t.multiple\n\t\t\tif what == 'no_combination' or (what == 'only_multiple' and not multiple) then\n\t\t\t\treturn false, { 'cvt_bad_unit', unitcode }\n\t\t\tend\n\t\t\t-- Recursively create a combination table containing the\n\t\t\t-- converter table of each unitcode.\n\t\t\tlocal result = { utype = t.utype, multiple = multiple, combination = {} }\n\t\t\tlocal cvt = result.combination\n\t\t\tfor i, v in ipairs(combo) do\n\t\t\t\tlocal success, t = lookup(v, opt_sp_us, multiple and 'no_combination' or 'only_multiple', utable, fails, depth)\n\t\t\t\tif not success then return false, t end\n\t\t\t\tcvt[i] = t\n\t\t\tend\n\t\t\treturn true, result\n\t\tend\n\t\tlocal result = shallow_copy(t)\n\t\tresult.sp_us = force_sp_us\n\t\tif result.prefixes then\n\t\t\tresult.symbol = result._symbol\n\t\t\tresult.name1 = result._name1\n\t\t\tresult.name1_us = result._name1_us\n\t\tend\n\t\treturn true, setmetatable(result, unit_mt)\n\tend\n\tlocal SIprefixes = text_code.SIprefixes\n\tfor plen = SIprefixes[1] or 2, 1, -1 do\n\t\t-- Look for an SI prefix; should never occur with an alias.\n\t\t-- Check for longer prefix first ('dam' is decametre).\n\t\t-- SIprefixes[1] = prefix maximum #characters (as seen by mw.ustring.sub).\n\t\tlocal prefix = usub(unitcode, 1, plen)\n\t\tlocal si = SIprefixes[prefix]\n\t\tif si then\n\t\t\tlocal t = utable[usub(unitcode, plen+1)]\n\t\t\tif t and t.prefixes then\n\t\t\t\tlocal result = shallow_copy(t)\n\t\t\t\tif opt_sp_us then\n\t\t\t\t\tresult.sp_us = true\n\t\t\t\tend\n\t\t\t\tif result.sp_us and si.name_us then\n\t\t\t\t\tresult.si_name = si.name_us\n\t\t\t\telse\n\t\t\t\t\tresult.si_name = si.name\n\t\t\t\tend\n\t\t\t\tresult.si_prefix = si.prefix or prefix\n\t\t\t\tresult.scale = t.scale * 10 ^ (si.exponent * t.prefixes)\n\t\t\t\treturn true, setmetatable(result, unit_prefixed_mt)\n\t\t\tend\n\t\tend\n\tend\n\t-- Accept any unit with an engineering notation prefix like \"e6cuft\"\n\t-- (million cubic feet), but not chained prefixes like \"e3e6cuft\",\n\t-- and not if the unit is a combination or multiple,\n\t-- and not if the unit has an offset or is a built-in.\n\t-- Only en digits are accepted.\n\tlocal has_plus = unitcode:find('+', 1, true)\n\tif not has_plus then\n\t\tlocal exponent, baseunit = unitcode:match('^e(%d+)(.*)')\n\t\tif exponent then\n\t\t\tlocal engscale = text_code.eng_scales[exponent]\n\t\t\tif engscale then\n\t\t\t\tlocal success, result = lookup(baseunit, opt_sp_us, 'no_combination', utable, fails, depth)\n\t\t\t\tif not success then return false, result end\n\t\t\t\tif not (result.offset or result.builtin or result.engscale) then\n\t\t\t\t\tresult.defkey = unitcode  -- key to lookup default exception\n\t\t\t\t\tresult.engscale = engscale\n\t\t\t\t\tresult.scale = result.scale * 10 ^ tonumber(exponent)\n\t\t\t\t\treturn true, result\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t-- Accept user-defined combinations like \"acre+m2+ha\" or \"acre m2 ha\" for output.\n\t-- If '+' is used, each unit code can include a space, and any error is fatal.\n\t-- If ' ' is used and if each space-separated word is a unit code, it is a combo,\n\t-- but errors are not fatal so the unit code can be looked up as an extra unit.\n\tlocal err_is_fatal\n\tlocal combo = collection()\n\tif has_plus then\n\t\terr_is_fatal = true\n\t\tfor item in (unitcode .. '+'):gmatch('%s*(.-)%s*%+') do\n\t\t\tif item ~= '' then\n\t\t\t\tcombo:add(item)\n\t\t\tend\n\t\tend\n\telseif unitcode:find('%s') then\n\t\tfor item in unitcode:gmatch('%S+') do\n\t\t\tcombo:add(item)\n\t\tend\n\tend\n\tif combo.n > 1 then\n\t\tlocal function lookup_combo()\n\t\t\tif what == 'no_combination' or what == 'only_multiple' then\n\t\t\t\treturn false, { 'cvt_bad_unit', unitcode }\n\t\t\tend\n\t\t\tlocal result = { combination = {} }\n\t\t\tlocal cvt = result.combination\n\t\t\tfor i, v in ipairs(combo) do\n\t\t\t\tlocal success, t = lookup(v, opt_sp_us, 'only_multiple', utable, fails, depth)\n\t\t\t\tif not success then return false, t end\n\t\t\t\tif i == 1 then\n\t\t\t\t\tresult.utype = t.utype\n\t\t\t\telse\n\t\t\t\t\tlocal mismatch = check_mismatch(result, t)\n\t\t\t\t\tif mismatch then\n\t\t\t\t\t\treturn false, mismatch\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tcvt[i] = t\n\t\t\tend\n\t\t\treturn true, result\n\t\tend\n\t\tlocal success, result = lookup_combo()\n\t\tif success or err_is_fatal then\n\t\t\treturn success, result\n\t\tend\n\tend\n\tif not extra_units then\n\t\tlocal success, extra = pcall(function () return require(extra_module).extra_units end)\n\t\tif success and type(extra) == 'table' then\n\t\t\textra_units = extra\n\t\tend\n\tend\n\tif extra_units then\n\t\t-- A unit in one data table might refer to a unit in the other table, so\n\t\t-- switch between them, relying on fails or depth to terminate loops.\n\t\tif not fails[unitcode] then\n\t\t\tfails[unitcode] = true\n\t\t\tlocal other = (utable == all_units) and extra_units or all_units\n\t\t\tlocal success, result = lookup(unitcode, opt_sp_us, what, other, fails, depth)\n\t\t\tif success then\n\t\t\t\treturn true, result\n\t\t\tend\n\t\tend\n\tend\n\treturn false, { 'cvt_unknown', unitcode }\nend\n\nlocal function valid_number(num)\n\t-- Return true if num is a valid number.\n\t-- In Scribunto (different from some standard Lua), when expressed as a string,\n\t-- overflow or other problems are indicated with text like \"inf\" or \"nan\"\n\t-- which are regarded as invalid here (each contains \"n\").\n\tif type(num) == 'number' and tostring(num):find('n', 1, true) == nil then\n\t\treturn true\n\tend\nend\n\nlocal function ntsh(num, debug)\n\t-- Return html text to be used for a hidden sort key so that\n\t-- the given number will be sorted in numeric order.\n\t-- If debug == true, output is in a box (not hidden).\n\t-- This implements Template:Ntsh (number table sorting, hidden).\n\tlocal result, style\n\tif not valid_number(num) then\n\t\tif num < 0 then\n\t\t\tresult = '1000000000000000000'\n\t\telse\n\t\t\tresult = '9000000000000000000'\n\t\tend\n\telseif num == 0 then\n\t\tresult = '5000000000000000000'\n\telse\n\t\tlocal mag = floor(log10(abs(num)) + 1e-14)\n\t\tlocal prefix\n\t\tif num > 0 then\n\t\t\tprefix = 7000 + mag\n\t\telse\n\t\t\tprefix = 2999 - mag\n\t\t\tnum = num + 10^(mag+1)\n\t\tend\n\t\tresult = format('%d', prefix) .. format('%015.0f', floor(num * 10^(14-mag)))\n\tend\n\tif debug then\n\t\tstyle = 'border:1px solid'\n\telse\n\t\tstyle = 'display:none'\n\tend\n\treturn '",{"type":"<","value":["span",{"style":"' .. style .. '"},["' .. result .. '"]]},"'\nend\n\nlocal function hyphenated(name, parts)\n\t-- Return a hyphenated form of given name (for adjectival usage).\n\t-- The name may be linked and the target of the link must not be changed.\n\t-- Hypothetical examples:\n\t--   ",{"type":"[[","value":[["long ton"],["ton"]]},"         →  ",{"type":"[[","value":[["long ton"],["ton"]]},"          (no change)\n\t--   ",{"type":"[[","value":[["tonne"],["long ton"]]},"       →  ",{"type":"[[","value":[["tonne"],["long-ton"]]},"\n\t--   ",{"type":"[[","value":[["metric ton"],["long ton"]]},"  →  ",{"type":"[[","value":[["metric ton"],["long-ton"]]},"\n\t--   ",{"type":"[[","value":[["long ton"]]},"             →  ",{"type":"[[","value":[["long ton"],["long-ton"]]},"\n\t-- Input can also have multiple links in a single name like:\n\t--   ",{"type":"[[","value":[["United States customary units"],["U.S."]]}," ",{"type":"[[","value":[["US gallon"],["gallon"]]},"\n\t--   ",{"type":"[[","value":[["mile"]]},"s per ",{"type":"[[","value":[["United States customary units"],["U.S."]]}," ",{"type":"[[","value":[["quart"]]},"\n\t--   ",{"type":"[[","value":[["long ton"]]},"s per ",{"type":"[[","value":[["short ton"]]},"\n\t-- Assume that links cannot be nested (never like \"",{"type":"[[","value":[["abc",{"type":"[[","value":[["def"]]},"ghi"]]},"\").\n\t-- This uses a simple and efficient procedure that works for most cases.\n\t-- Some units (if used) would require more, and can later think about\n\t-- adding a method to handle exceptions.\n\t-- The procedure is to replace each space with a hyphen, but\n\t-- not a space after ')' [for \"(pre-1954 US) nautical mile\"], and\n\t-- not spaces immediately before '(' or in '(...)' [for cases like\n\t-- \"British thermal unit (ISO)\" and \"Calorie (International Steam Table)\"].\n\tif name:find(' ', 1, true) then\n\t\tif parts then\n\t\t\tlocal pos\n\t\t\tif name:sub(1, 1) == '(' then\n\t\t\t\tpos = name:find(')', 1, true)\n\t\t\t\tif pos then\n\t\t\t\t\treturn name:sub(1, pos+1) .. name:sub(pos+2):gsub(' ', '-')\n\t\t\t\tend\n\t\t\telseif name:sub(-1, -1) == ')' then\n\t\t\t\tpos = name:find('(', 1, true)\n\t\t\t\tif pos then\n\t\t\t\t\treturn name:sub(1, pos-2):gsub(' ', '-') .. name:sub(pos-1)\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn name:gsub(' ', '-')\n\t\tend\n\t\tparts = collection()\n\t\tfor before, item, after in name:gmatch('([^[]*)(%[%",{"type":"[[","value":[["^[]*%]%])([^[]*)') do\n\t\t\tif item:find(' ', 1, true) then\n\t\t\t\tlocal prefix\n\t\t\t\tlocal plen = item:find('"],["', 1, true)\n\t\t\t\tif plen then\n\t\t\t\t\tprefix = item:sub(1, plen)\n\t\t\t\t\titem = item:sub(plen + 1, -3)\n\t\t\t\telse\n\t\t\t\t\tprefix = item:sub(1, -3) .. '"],["'\n\t\t\t\t\titem = item:sub(3, -3)\n\t\t\t\tend\n\t\t\t\titem = prefix .. hyphenated(item, parts) .. '"]]},"'\n\t\t\tend\n\t\t\tparts:add(before:gsub(' ', '-') .. item .. after:gsub(' ', '-'))\n\t\tend\n\t\tif parts.n == 0 then\n\t\t\t-- No link like \"",{"type":"[[","value":[["..."]]},"\" was found in the original name.\n\t\t\tparts:add(hyphenated(name, parts))\n\t\tend\n\t\treturn table.concat(parts)\n\tend\n\treturn name\nend\n\nlocal function hyphenated_maybe(parms, want_name, sep, id, inout)\n\t-- Return s, f where\n\t--   s = id, possibly modified\n\t--   f = true if hyphenated\n\t-- Possible modifications: hyphenate; prepend '-'; append mid text.\n\tif id == nil or id == '' then\n\t\treturn ''\n\tend\n\tlocal mid\n\tif parms.opt_adjectival then\n\t\tif inout == (parms.opt_flip and 'out' or 'in') then\n\t\t\tmid = parms.mid\n\t\tend\n\t\tif want_name then\n\t\t\treturn '-' .. hyphenated(id) .. (mid or ''), true\n\t\tend\n\tend\n\treturn sep .. id .. (mid or '')\nend\n\nlocal function change_sign(text)\n\t-- Change sign of text for correct appearance because it is negated.\n\tif text:sub(1, 1) == '-' then\n\t\treturn text:sub(2)\n\tend\n\treturn '-' .. text\nend\n\nlocal function use_minus(text)\n\t-- Return text with Unicode minus instead of '-', if present.\n\tif text:sub(1, 1) == '-' then\n\t\treturn MINUS .. text:sub(2)\n\tend\n\treturn text\nend\n\nlocal function digit_grouper(method, gaps)\n\t-- Return a table to hold groups of digits which can be joined with\n\t-- suitable separators (such as commas).\n\t-- Each group is separately translated to the local language because\n\t-- gap separators include digits which should not be translated.\n\t-- Parameter method is a number or nil:\n\t--   3 for 3-digit grouping, or\n\t--   2 for 3-then-2 grouping.\n\t-- Parameter gaps is true to use <span> gaps (numsep ignored).\n\treturn {\n\t\tn = 0,\n\t\tadd = function (self, digits)\n\t\t\tself.n = self.n + 1\n\t\t\tself[self.n] = from_en(digits)\n\t\tend,\n\t\tjoin = function (self, rhs)\n\t\t\t-- Concatenate in reverse order.\n\t\t\tif gaps then\n\t\t\t\tlocal result = ''\n\t\t\t\tfor i = 1, self.n - 1 do\n\t\t\t\t\tresult = '",{"type":"<","value":["span",{"style":"margin-left: 0.25em"},["' .. self[i] .. '"]]},"' .. result\n\t\t\t\tend\n\t\t\t\treturn '",{"type":"<","value":["span",{"style":"white-space: nowrap"},["' .. self[self.n] .. result .. from_en(rhs) .. '"]]},"'\n\t\t\telse\n\t\t\t\tlocal result = self[1]\n\t\t\t\tfor i = 2, self.n do\n\t\t\t\t\tresult = self[i] .. numsep .. result\n\t\t\t\tend\n\t\t\t\treturn result .. from_en(rhs)\n\t\t\tend\n\t\tend,\n\t\tstep = 3,\n\t\tnext_position = function (self, previous)\n\t\t\t-- Return position of digit just before next group.\n\t\t\t-- Digits are grouped from right-to-left (least significant first).\n\t\t\tlocal result = previous - self.step\n\t\t\tif method == 2 then\n\t\t\t\tself.step = 2\n\t\t\tend\n\t\t\treturn (result < 0) and 0 or result\n\t\tend,\n\t}\nend\n\nlocal function with_separator(parms, text)\n\t-- Input text is a number in en digits and optional '.' decimal mark.\n\t-- Return an equivalent of text, formatted for display:\n\t--   with a custom decimal mark instead of '.', if wanted\n\t--   with thousand separators inserted, if wanted\n\t--   digits in local language\n\t-- The given text is like '123' or '12345.6789' or '1.23e45'\n\t-- (e notation can only occur when processing an input value).\n\t-- The text has no sign (caller inserts that later, if necessary).\n\t-- Separator is inserted only in the integer part of the significand\n\t-- (not after the decimal mark, and not after 'e' or 'E').\n\tif parms.opt_nocomma or numsep == '' then\n\t\treturn from_en(text)\n\tend\n\tlocal last = text:match('()[.eE]')  -- () returns position\n\tif last == nil then\n\t\tlast = #text\n\telse\n\t\tlast = last - 1  -- index of last character before dot\/e\/E\n\tend\n\tif last < 4 or (last == 4 and parms.opt_comma5) then\n\t\treturn from_en(text)\n\tend\n\tlocal groups = digit_grouper(group_method, parms.opt_gaps)\n\tlocal i = last\n\twhile i > 0 do\n\t\tlocal position = groups:next_position(i)\n\t\tgroups:add(text:sub(position+1, i))\n\t\ti = position\n\tend\n\treturn groups:join(text:sub(last+1))\nend\n\n-- Input values can use values like 1.23e12, but are never displayed\n-- using scientific notation like 1.23×10¹².\n-- Very small or very large output values use scientific notation.\n-- Use format(fmtpower, significand, '10', exponent) where each arg is a string.\nlocal fmtpower = '%s",{"type":"<","value":["span",{"style":"margin:0 .15em 0 .25em"},["×"]]},"%s",{"type":"<","value":["sup",["%s"]]},"'\n\nlocal function with_exponent(show, exponent)\n\t-- Return wikitext to display the implied value in scientific notation.\n\t-- Input uses en digits; output uses digits in local language.\n\tif #show > 1 then\n\t\tshow = show:sub(1, 1) .. '.' .. show:sub(2)\n\tend\n\treturn format(fmtpower, from_en(show), from_en('10'), use_minus(from_en(tostring(exponent))))\nend\n\nlocal function make_sigfig(value, sigfig)\n\t-- Return show, exponent that are equivalent to the result of\n\t-- converting the number 'value' (where value >= 0) to a string,\n\t-- rounded to 'sigfig' significant figures.\n\t-- The returned items are:\n\t--   show: a string of digits; no sign and no dot;\n\t--         there is an implied dot before show.\n\t--   exponent: a number (an integer) to shift the implied dot.\n\t-- Resulting value = tonumber('.' .. show) * 10^exponent.\n\t-- Examples:\n\t--   make_sigfig(23.456, 3) returns '235', 2 (.235 * 10^2).\n\t--   make_sigfig(0.0023456, 3) returns '235', -2 (.235 * 10^-2).\n\t--   make_sigfig(0, 3) returns '000', 1 (.000 * 10^1).\n\tif sigfig <= 0 then\n\t\tsigfig = 1\n\telseif sigfig > maxsigfig then\n\t\tsigfig = maxsigfig\n\tend\n\tif value == 0 then\n\t\treturn string.rep('0', sigfig), 1\n\tend\n\tlocal exp, fracpart = math.modf(log10(value))\n\tif fracpart >= 0 then\n\t\tfracpart = fracpart - 1\n\t\texp = exp + 1\n\tend\n\tlocal digits = format('%.0f', 10^(fracpart + sigfig))\n\tif #digits > sigfig then\n\t\t-- Overflow (for sigfig=3: like 0.9999 rounding to \"1000\"; need \"100\").\n\t\tdigits = digits:sub(1, sigfig)\n\t\texp = exp + 1\n\tend\n\tassert(#digits == sigfig, 'Bug: rounded number has wrong length')\n\treturn digits, exp\nend\n\n-- Fraction output format.\nlocal fracfmt = {\n\t{ -- Like ",{"type":"{{","value":[["frac"]]}," (fraction slash).\n\t\t-- 1\/2    : sign, numerator, denominator\n\t\t-- 1+2\/3  : signed_wholenumber, numerator, denominator\n\t\t'",{"type":"<","value":["span",{"class":"frac nowrap"},["%s",{"type":"<","value":["sup",["%s"]]},"⁄",{"type":"<","value":["sub",["%s"]]}]]},"',\n\t\t'",{"type":"<","value":["span",{"class":"frac nowrap"},["%s",{"type":"<","value":["span",{"class":"visualhide"},[" "]]},{"type":"<","value":["sup",["%s"]]},"⁄",{"type":"<","value":["sub",["%s"]]}]]},"',\n\t},\n\t{ -- Like ",{"type":"{{","value":[["sfrac"]]}," (fraction horizontal bar).\n\t\t-- 1\/\/2   : sign, numerator, denominator (sign should probably be before the fraction, but then it can wrap, and html is already too long)\n\t\t-- 1+2\/\/3 : signed_wholenumber, numerator, denominator\n\t\t'",{"type":"<","value":["span",{"class":"sfrac nowrap","style":"display:inline-block; vertical-align:-0.5em; font-size:85%%; text-align:center;"},[{"type":"<","value":["span",{"style":"display:block; line-height:1em; padding:0 0.1em;"},["%s%s"]]},{"type":"<","value":["span",{"class":"visualhide"},["\/"]]},{"type":"<","value":["span",{"style":"display:block; line-height:1em; padding:0 0.1em; border-top:1px solid;"},["%s"]]}]]},"',\n\t\t'",{"type":"<","value":["span",{"class":"sfrac nowrap"},["%s",{"type":"<","value":["span",{"class":"visualhide"},[" "]]},{"type":"<","value":["span",{"style":"display:inline-block; vertical-align:-0.5em; font-size:85%%; text-align:center;"},[{"type":"<","value":["span",{"style":"display:block; line-height:1em; padding:0 0.1em;"},["%s"]]},{"type":"<","value":["span",{"class":"visualhide"},["\/"]]},{"type":"<","value":["span",{"style":"display:block; line-height:1em; padding:0 0.1em; border-top:1px solid;"},["%s"]]}]]}]]},"',\n\t},\n}\n\nlocal function format_fraction(parms, inout, negative, wholestr, numstr, denstr, do_spell, style)\n\t-- Return wikitext for a fraction, possibly spelled.\n\t-- Inputs use en digits and have no sign; output uses digits in local language.\n\tlocal wikitext\n\tif not style then\n\t\tstyle = parms.opt_fraction_horizontal and 2 or 1\n\tend\n\tif wholestr == '' then\n\t\twholestr = nil\n\tend\n\tif wholestr then\n\t\tlocal decorated = with_separator(parms, wholestr)\n\t\tif negative then\n\t\t\tdecorated = MINUS .. decorated\n\t\tend\n\t\tlocal fmt = fracfmt[style][2]\n\t\twikitext = format(fmt, decorated, from_en(numstr), from_en(denstr))\n\telse\n\t\tlocal sign = negative and MINUS or ''\n\t\twikitext = format(fracfmt[style][1], sign, from_en(numstr), from_en(denstr))\n\tend\n\tif do_spell then\n\t\tif negative then\n\t\t\tif wholestr then\n\t\t\t\twholestr = '-' .. wholestr\n\t\t\telse\n\t\t\t\tnumstr = '-' .. numstr\n\t\t\tend\n\t\tend\n\t\twikitext = spell_number(parms, inout, wholestr, numstr, denstr) or wikitext\n\tend\n\treturn wikitext\nend\n\nlocal function format_number(parms, show, exponent, isnegative)\n\t-- Parameter show is a string or a table containing strings.\n\t-- Each string is a formatted number in en digits and optional '.' decimal mark.\n\t-- A table represents a fraction: integer, numerator, denominator;\n\t-- if a table is given, exponent must be nil.\n\t-- Return t where t is a table with fields:\n\t--   show = wikitext formatted to display implied value\n\t--          (digits in local language)\n\t--   is_scientific = true if show uses scientific notation\n\t--   clean = unformatted show (possibly adjusted and with inserted '.')\n\t--          (en digits)\n\t--   sign = '' or MINUS\n\t--   exponent = exponent (possibly adjusted)\n\t-- The clean and exponent fields can be used to calculate the\n\t-- rounded absolute value, if needed.\n\t--\n\t-- The value implied by the arguments is found from:\n\t--   exponent is nil; and\n\t--   show is a string of digits (no sign), with an optional dot;\n\t--   show = '123.4' is value 123.4, '1234' is value 1234.0;\n\t-- or:\n\t--   exponent is an integer indicating where dot should be;\n\t--   show is a string of digits (no sign and no dot);\n\t--   there is an implied dot before show;\n\t--   show does not start with '0';\n\t--   show = '1234', exponent = 3 is value 0.1234*10^3 = 123.4.\n\t--\n\t-- The formatted result:\n\t-- * Is for an output value and is spelled if wanted and possible.\n\t-- * Includes a Unicode minus if isnegative and not spelled.\n\t-- * Uses a custom decimal mark, if wanted.\n\t-- * Has digits grouped where necessary, if wanted.\n\t-- * Uses scientific notation for very small or large values\n\t--   (which forces output to not be spelled).\n\t-- * Has no more than maxsigfig significant digits\n\t--   (same as old template and ",{"type":"{{","value":[["#expr"]]},").\n\tlocal sign = isnegative and MINUS or ''\n\tlocal maxlen = maxsigfig\n\tlocal tfrac\n\tif type(show) == 'table' then\n\t\ttfrac = show\n\t\tshow = tfrac.wholestr\n\t\tassert(exponent == nil, 'Bug: exponent given with fraction')\n\tend\n\tif not tfrac and not exponent then\n\t\tlocal integer, dot, decimals = show:match('^(%d*)(%.?)(.*)')\n\t\tif #integer >= 10 then\n\t\t\tshow = integer .. decimals\n\t\t\texponent = #integer\n\t\telseif integer == '0' or integer == '' then\n\t\t\tlocal zeros, figs = decimals:match('^(0*)([^0]?.*)')\n\t\t\tif #figs == 0 then\n\t\t\t\tif #zeros > maxlen then\n\t\t\t\t\tshow = '0.' .. zeros:sub(1, maxlen)\n\t\t\t\tend\n\t\t\telseif #zeros >= 4 then\n\t\t\t\tshow = figs\n\t\t\t\texponent = -#zeros\n\t\t\telseif #figs > maxlen then\n\t\t\t\tshow = '0.' .. zeros .. figs:sub(1, maxlen)\n\t\t\tend\n\t\telse\n\t\t\tmaxlen = maxlen + #dot\n\t\t\tif #show > maxlen then\n\t\t\t\tshow = show:sub(1, maxlen)\n\t\t\tend\n\t\tend\n\tend\n\tif exponent then\n\t\tif #show > maxlen then\n\t\t\tshow = show:sub(1, maxlen)\n\t\tend\n\t\tif exponent > 10 or exponent <= -4 or (exponent == 10 and show ~= '1000000000') then\n\t\t\t-- Rounded value satisfies: value >= 1e9 or value < 1e-4 (1e9 = 0.1e10).\n\t\t\treturn {\n\t\t\t\tclean = '.' .. show,\n\t\t\t\texponent = exponent,\n\t\t\t\tsign = sign,\n\t\t\t\tshow = sign .. with_exponent(show, exponent-1),\n\t\t\t\tis_scientific = true,\n\t\t\t}\n\t\tend\n\t\tif exponent >= #show then\n\t\t\tshow = show .. string.rep('0', exponent - #show)  -- result has no dot\n\t\telseif exponent <= 0 then\n\t\t\tshow = '0.' .. string.rep('0', -exponent) .. show\n\t\telse\n\t\t\tshow = show:sub(1, exponent) .. '.' .. show:sub(exponent+1)\n\t\tend\n\tend\n\tlocal formatted_show\n\tif tfrac then\n\t\tshow = tostring(tfrac.value)  -- to set clean in returned table\n\t\tformatted_show = format_fraction(parms, 'out', isnegative, tfrac.wholestr, tfrac.numstr, tfrac.denstr, parms.opt_spell_out)\n\telse\n\t\tif isnegative and show:match('^0.?0*$') then\n\t\t\tsign = ''  -- don't show minus if result is negative but rounds to zero\n\t\tend\n\t\tformatted_show = sign .. with_separator(parms, show)\n\t\tif parms.opt_spell_out then\n\t\t\tformatted_show = spell_number(parms, 'out', sign .. show) or formatted_show\n\t\tend\n\tend\n\treturn {\n\t\tclean = show,\n\t\tsign = sign,\n\t\tshow = formatted_show,\n\t\tis_scientific = false,  -- to avoid calling __index\n\t}\nend\n\nlocal function extract_fraction(parms, text, negative)\n\t-- If text represents a fraction, return\n\t--   value, altvalue, show, spelled, denominator\n\t-- where\n\t--   value is a number (value of the fraction in argument text)\n\t--   altvalue is an alternate interpretation of any fraction for the hands\n\t--        unit where \"14.1+3\/4\" means 14 hands 1.75 inches!\n\t--   show is a string (formatted text for display of an input value,\n\t--        and is spelled if wanted and possible)\n\t--   spelled is true if show was spelled\n\t--   denominator is value of the denominator in the fraction\n\t-- Otherwise, return nil.\n\t-- Input uses en digits and '.' decimal mark (input has been translated).\n\t-- Output uses digits in local language and custom decimal mark, if any.\n\t--\n\t-- In the following, '(3\/8)' represents the wikitext required to\n\t-- display a fraction with numerator 3 and denominator 8.\n\t-- In the wikitext, Unicode minus is used for a negative value.\n\t--   text          value, show            value, show\n\t--                 if not negative       if negative\n\t--   3 \/ 8         0.375, '(3\/8)'        -0.375, '−(3\/8)'\n\t--   2 + 3 \/ 8     2.375, '2(3\/8)'       -1.625, '−2(−3\/8)'\n\t--   2 - 3 \/ 8     1.625, '2(−3\/8)'      -2.375, '−2(3\/8)'\n\t--   1 + 20\/8      3.5  , '1\/(20\/8)'     1.5   , '−1\/(−20\/8)'\n\t--   1 - 20\/8      -1.5., '1(−20\/8)'     -3.5  , '−1(20\/8)'\n\t-- Wherever an integer appears above, numbers like 1.25 or 12.5e-3\n\t-- (which may be negative) are also accepted (like old template).\n\t-- Old template interprets '1.23e+2+12\/24' as '123(12\/24)' = 123.5!\n\tlocal numstr, whole, value, altvalue\n\tlocal lhs, slash, denstr = text:match('^%s*([^\/]-)%s*(\/+)%s*(.-)%s*$')\n\tlocal denominator = tonumber(denstr)\n\tif denominator == nil then return nil end\n\tlocal wholestr, negfrac, rhs = lhs:match('^%s*(.-[^eE])%s*([+-])%s*(.-)%s*$')\n\tif wholestr == nil or wholestr == '' then\n\t\twholestr = nil\n\t\twhole = 0\n\t\tnumstr = lhs\n\telse\n\t\twhole = tonumber(wholestr)\n\t\tif whole == nil then return nil end\n\t\tnumstr = rhs\n\tend\n\tnegfrac = (negfrac == '-')\n\tlocal numerator = tonumber(numstr)\n\tif numerator == nil then return nil end\n\t-- Spelling of silly inputs like \"-2+3\/8\" or \"2+3\/+8\" (mixed or excess signs) is not supported.\n\tlocal do_spell\n\tif negative == negfrac or wholestr == nil then\n\t\tvalue = whole + numerator \/ denominator\n\t\taltvalue = whole + numerator \/ (denominator * 10)\n\t\tdo_spell = parms.opt_spell_in\n\t\tif do_spell then\n\t\t\tif not (numstr:match('^%d') and denstr:match('^%d')) then  -- if either has a sign\n\t\t\t\tdo_spell = false\n\t\t\tend\n\t\tend\n\telse\n\t\tvalue = whole - numerator \/ denominator\n\t\taltvalue = whole - numerator \/ (denominator * 10)\n\t\tnumstr = change_sign(numstr)\n\t\tdo_spell = false\n\tend\n\tif not valid_number(value) then\n\t\treturn nil  -- overflow or similar\n\tend\n\tnumstr = use_minus(numstr)\n\tdenstr = use_minus(denstr)\n\tlocal style = #slash  -- kludge: 1 or 2 slashes can be used to select style\n\tif style > 2 then style = 2 end\n\tlocal wikitext = format_fraction(parms, 'in', negative, wholestr, numstr, denstr, do_spell, style)\n\treturn value, altvalue, wikitext, do_spell, denominator\nend\n\nlocal function extract_number(parms, text, another, no_fraction)\n\t-- Return true, info if can extract a number from text,\n\t-- where info is a table with the result,\n\t-- or return false, t where t is an error message table.\n\t-- Input can use en digits or digits in local language.\n\t-- Parameter another = true if the expected value is not the first.\n\t-- Before processing, the input text is cleaned:\n\t-- * Any thousand separators (valid or not) are removed.\n\t-- * Any sign (and optional following whitespace) is replaced with\n\t--   '-' (if negative) or '' (otherwise).\n\t--   That replaces Unicode minus with '-'.\n\t-- If successful, the returned info table contains named fields:\n\t--   value    = a valid number\n\t--   altvalue = a valid number, usually same as value but different\n\t--              if fraction used (for hands unit)\n\t--   singular = true if value is 1 (to use singular form of units)\n\t--            = false if value is -1 (like old template)\n\t--   clean    = cleaned text with any separators and sign removed\n\t--              (en digits and '.' decimal mark)\n\t--   show     = text formatted for output\n\t--              (digits in local language and custom decimal mark)\n\t-- The resulting show:\n\t-- * Is for an input value and is spelled if wanted and possible.\n\t-- * Has a rounded value, if wanted.\n\t-- * Has digits grouped where necessary, if wanted.\n\t-- * If negative, a Unicode minus is used; otherwise the sign is\n\t--   '+' (if the input text used '+'), or is '' (if no sign in input).\n\ttext = strip(text or '')\n\tlocal clean = to_en(text)\n\tif clean == '' then\n\t\treturn false, { another and 'cvt_no_num2' or 'cvt_no_num' }\n\tend\n\tlocal isnegative, propersign = false, ''  -- most common case\n\tlocal singular, show, denominator\n\tlocal value = tonumber(clean)\n\tlocal altvalue\n\tif value then\n\t\tlocal sign = clean:sub(1, 1)\n\t\tif sign == '+' or sign == '-' then\n\t\t\tpropersign = (sign == '+') and '+' or MINUS\n\t\t\tclean = clean:sub(2)\n\t\tend\n\t\tif value < 0 then\n\t\t\tisnegative = true\n\t\t\tvalue = -value\n\t\tend\n\telse\n\t\tlocal valstr\n\t\tfor _, prefix in ipairs({ '-', MINUS, '−' }) do\n\t\t\t-- Including '-' means inputs like '- 2' (with space) are accepted as -2.\n\t\t\t-- It also sets isnegative in case input is a fraction like '-2-3\/4'.\n\t\t\tlocal plen = #prefix\n\t\t\tif clean:sub(1, plen) == prefix then\n\t\t\t\tvalstr = clean:sub(plen + 1)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif valstr then\n\t\t\tisnegative = true\n\t\t\tpropersign = MINUS\n\t\t\tclean = valstr\n\t\t\tvalue = tonumber(clean)\n\t\tend\n\t\tif value == nil then\n\t\t\tlocal spelled\n\t\t\tif not no_fraction then\n\t\t\t\tvalue, altvalue, show, spelled, denominator = extract_fraction(parms, clean, isnegative)\n\t\t\tend\n\t\t\tif value == nil then\n\t\t\t\treturn false, { 'cvt_bad_num', text }\n\t\t\tend\n\t\t\tif value <= 1 then\n\t\t\t\tsingular = true  -- for example, \"½ mile\" or \"one half mile\" (singular unit)\n\t\t\tend\n\t\tend\n\tend\n\tif not valid_number(value) then  -- for example, \"1e310\" may overflow\n\t\treturn false, { 'cvt_invalid_num' }\n\tend\n\tif show == nil then\n\t\tsingular = (value == 1 and not isnegative)\n\t\tlocal precision = parms.input_precision\n\t\tif precision and 0 <= precision and precision <= 8 then\n\t\t\tlocal fmt = '%.' .. format('%d', precision) .. 'f'\n\t\t\tshow = fmt:format(value + 2e-14)  -- fudge for some common cases of bad rounding\n\t\telse\n\t\t\tshow = clean\n\t\tend\n\t\tshow = propersign .. with_separator(parms, show)\n\t\tif parms.opt_spell_in then\n\t\t\tshow = spell_number(parms, 'in', propersign .. clean) or show\n\t\tend\n\tend\n\tlocal altvalue = altvalue or value\n\tif isnegative and (value ~= 0) then\n\t\tvalue = -value\n\t\taltvalue = -altvalue\n\tend\n\treturn true, {\n\t\tvalue = value,\n\t\taltvalue = altvalue,\n\t\tsingular = singular,\n\t\tclean = clean,\n\t\tshow = show,\n\t\tdenominator = denominator,\n\t}\nend\n\nlocal function get_number(text)\n\t-- Return v, f where:\n\t--   v = nil (text is not a number)\n\t-- or\n\t--   v = value of text (text is a number)\n\t--   f = true if value is an integer\n\t-- Input can use en digits or digits in local language,\n\t-- but no separators, no Unicode minus, and no fraction.\n\tif text then\n\t\tlocal number = tonumber(to_en(text))\n\t\tif number then\n\t\t\tlocal integer, fracpart = math.modf(number)\n\t\t\treturn number, (fracpart == 0)\n\t\tend\n\tend\nend\n\nlocal function gcd(a, b)\n\t-- Return the greatest common denominator for the given values,\n\t-- which are known to be positive integers.\n\tif a > b then\n\t\ta, b = b, a\n\tend\n\tif a <= 0 then\n\t\treturn b\n\tend\n\tlocal r = b % a\n\tif r <= 0 then\n\t\treturn a\n\tend\n\tif r == 1 then\n\t\treturn 1\n\tend\n\treturn gcd(r, a)\nend\n\nlocal function fraction_table(value, denominator)\n\t-- Return value as a string or a table:\n\t-- * If result is a string, there is no fraction, and the result\n\t--   is value formatted as a string of en digits.\n\t-- * If result is a table, it represents a fraction with named fields:\n\t--   wholestr, numstr, denstr (strings of en digits for integer, numerator, denominator).\n\t-- The result is rounded to the nearest multiple of (1\/denominator).\n\t-- If the multiple is zero, no fraction is included.\n\t-- No fraction is included if value is very large as the fraction would\n\t-- be unhelpful, particularly if scientific notation is required.\n\t-- Input value is a non-negative number.\n\t-- Input denominator is a positive integer for the desired fraction.\n\tif value <= 0 then\n\t\treturn '0'\n\tend\n\tif denominator <= 0 or value > 1e8 then\n\t\treturn format('%.2f', value)\n\tend\n\tlocal integer, decimals = math.modf(value)\n\tlocal numerator = floor((decimals * denominator) +\n\t\t0.5 + 2e-14)  -- add fudge for some common cases of bad rounding\n\tif numerator >= denominator then\n\t\tinteger = integer + 1\n\t\tnumerator = 0\n\tend\n\tlocal wholestr = tostring(integer)\n\tif numerator > 0 then\n\t\tlocal div = gcd(numerator, denominator)\n\t\tif div > 1 then\n\t\t\tnumerator = numerator \/ div\n\t\t\tdenominator = denominator \/ div\n\t\tend\n\t\treturn {\n\t\t\twholestr = (integer > 0) and wholestr or '',\n\t\t\tnumstr = tostring(numerator),\n\t\t\tdenstr = tostring(denominator),\n\t\t\tvalue = value,\n\t\t}\n\tend\n\treturn wholestr\nend\n\nlocal function preunits(count, preunit1, preunit2)\n\t-- If count is 1:\n\t--     ignore preunit2\n\t--     return p1\n\t-- else:\n\t--     preunit1 is used for preunit2 if the latter is empty\n\t--     return p1, p2\n\t-- where:\n\t--     p1 is text to insert before the input unit\n\t--     p2 is text to insert before the output unit\n\t--     p1 or p2 may be nil to mean \"no preunit\"\n\t-- Using '+ ' gives output like \"5+ feet\" (no preceding space).\n\tlocal function withspace(text, i)\n\t\t-- Insert space at beginning if i == 1, or at end if i == -1.\n\t\t-- However, no space is inserted if there is a space or ' '\n\t\t-- or '-' at that position ('-' is for adjectival text).\n\t\tlocal current = text:sub(i, i)\n\t\tif current == ' ' or current == '-' then\n\t\t\treturn text\n\t\tend\n\t\tif i == 1 then\n\t\t\tcurrent = text:sub(1, 6)\n\t\telse\n\t\t\tcurrent = text:sub(-6, -1)\n\t\tend\n\t\tif current == ' ' then\n\t\t\treturn text\n\t\tend\n\t\tif i == 1 then\n\t\t\treturn ' ' .. text\n\t\tend\n\t\treturn text .. ' '\n\tend\n\tpreunit1 = preunit1 or ''\n\tlocal trim1 = strip(preunit1)\n\tif count == 1 then\n\t\tif trim1 == '' then\n\t\t\treturn nil\n\t\tend\n\t\treturn withspace(withspace(preunit1, 1), -1)\n\tend\n\tpreunit2 = preunit2 or ''\n\tlocal trim2 = strip(preunit2)\n\tif trim1 == ",{"type":"''","value":[" and trim2 == "]}," then\n\t\treturn nil, nil\n\tend\n\tif trim1 ~= '+' then\n\t\tpreunit1 = withspace(preunit1, 1)\n\tend\n\tif trim2 == ' ' then  -- trick to make preunit2 empty\n\t\tpreunit2 = nil\n\telseif trim2 == '' then\n\t\tpreunit2 = preunit1\n\telseif trim2 ~= '+' then\n\t\tpreunit2 = withspace(preunit2, 1)\n\tend\n\treturn preunit1, preunit2\nend\n\nlocal function range_text(range, want_name, parms, before, after)\n\t-- Return before .. rtext .. after\n\t-- where rtext is the text that separates two values in a range.\n\tlocal rtext, adj_text, exception\n\tif type(range) == 'table' then\n\t\t-- Table must specify range text for abbr=off and for abbr=on,\n\t\t-- and may specify range text for 'adj=on',\n\t\t-- and may specify exception = true.\n\t\trtext = range[want_name and 'off' or 'on']\n\t\tadj_text = range['adj']\n\t\texception = range['exception']\n\telse\n\t\trtext = range\n\tend\n\tif parms.opt_adjectival then\n\t\tif want_name or (exception and parms.abbr_org == 'on') then\n\t\t\trtext = adj_text or rtext:gsub(' ', '-'):gsub(' ', '-')\n\t\tend\n\tend\n\tif rtext == '–' and after:sub(1, #MINUS) == MINUS then\n\t\trtext = ' – '\n\tend\n\treturn before .. rtext .. after\nend\n\nlocal function get_composite(parms, iparm, total, in_unit_table)\n\t-- Look for a composite input unit. For example, \"",{"type":"{{","value":[["convert"],["1"],["yd"],["2"],["ft"],["3"],["in"]]},"\"\n\t-- would result in a call to this function with\n\t--   iparm = 3 (parms[iparm] = \"2\", just after the first unit)\n\t--   total = 1 (number of yards)\n\t--   in_unit_table = (unit table for \"yd\")\n\t-- Return true, iparm, unit where\n\t--   iparm = index just after the composite units (7 in above example)\n\t--   unit = composite unit table holding all input units,\n\t-- or return true if no composite unit is present in parms,\n\t-- or return false, t where t is an error message table.\n\tlocal default, subinfo\n\tlocal composite_units, count = { in_unit_table }, 1\n\tlocal fixups = {}\n\tlocal subunit = in_unit_table\n\twhile subunit.subdivs do  -- subdivs is nil or a table of allowed subdivisions\n\t\tlocal subcode = strip(parms[iparm+1])\n\t\tlocal subdiv = subunit.subdivs[subcode]\n\t\tif not subdiv then\n\t\t\tbreak\n\t\tend\n\t\tlocal success\n\t\tsuccess, subunit = lookup(subcode, parms.opt_sp_us, 'no_combination')\n\t\tif not success then return false, subunit end  -- should never occur\n\t\tsuccess, subinfo = extract_number(parms, parms[iparm])\n\t\tif not success then return false, subinfo end\n\t\tiparm = iparm + 2\n\t\tsubunit.inout = 'in'\n\t\tsubunit.valinfo = { subinfo }\n\t\t-- Recalculate total as a number of subdivisions.\n\t\t-- subdiv[1] = number of subdivisions per previous unit (integer > 1).\n\t\ttotal = total * subdiv[1] + subinfo.value\n\t\tif not default then  -- set by the first subdiv with a default defined\n\t\t\tdefault = subdiv.default\n\t\tend\n\t\tcount = count + 1\n\t\tcomposite_units[count] = subunit\n\t\tif subdiv.unit or subdiv.name then\n\t\t\tfixups[count] = { unit = subdiv.unit, name = subdiv.name, valinfo = subunit.valinfo }\n\t\tend\n\tend\n\tif count == 1 then\n\t\treturn true  -- no error and no composite unit\n\tend\n\tfor i, fixup in pairs(fixups) do\n\t\tlocal unit = fixup.unit\n\t\tlocal name = fixup.name\n\t\tif not unit or (count > 2 and name) then\n\t\t\tcomposite_units[i].fixed_name = name\n\t\telse\n\t\t\tlocal success, alternate = lookup(unit, parms.opt_sp_us, 'no_combination')\n\t\t\tif not success then return false, alternate end  -- should never occur\n\t\t\talternate.inout = 'in'\n\t\t\talternate.valinfo = fixup.valinfo\n\t\t\tcomposite_units[i] = alternate\n\t\tend\n\tend\n\treturn true, iparm, {\n\t\tutype = in_unit_table.utype,\n\t\tscale = subunit.scale,  -- scale of last (least significant) unit\n\t\tvalinfo = { { value = total, clean = subinfo.clean, denominator = subinfo.denominator } },\n\t\tcomposite = composite_units,\n\t\tdefault = default or in_unit_table.default\n\t}\nend\n\nlocal function translate_parms(parms, kv_pairs)\n\t-- Update fields in parms by translating each key:value in kv_pairs to terms\n\t-- used by this module (may involve translating from local language to English).\n\t-- Also, checks are performed which may display warnings, if enabled.\n\t-- Return true if successful or return false, t where t is an error message table.\n\tif kv_pairs.adj and kv_pairs.sing then\n\t\t-- For en.wiki (before translation), warn if attempt to use adj and sing\n\t\t-- as the latter is a deprecated alias for the former.\n\t\tif kv_pairs.adj ~= kv_pairs.sing and kv_pairs.sing ~= '' then\n\t\t\tadd_warning(parms, 1, 'cvt_unknown_option', 'sing=' .. kv_pairs.sing)\n\t\tend\n\t\tkv_pairs.sing = nil\n\tend\n\tfor loc_name, loc_value in pairs(kv_pairs) do\n\t\tlocal en_name = text_code.en_option_name[loc_name]\n\t\tif en_name then\n\t\t\tlocal en_value\n\t\t\tif en_name == 'frac' or en_name == 'sigfig' then\n\t\t\t\tif loc_value == '' then\n\t\t\t\t\tadd_warning(parms, 2, 'cvt_empty_option', loc_name)\n\t\t\t\telse\n\t\t\t\t\tlocal minimum\n\t\t\t\t\tlocal number, is_integer = get_number(loc_value)\n\t\t\t\t\tif en_name == 'frac' then\n\t\t\t\t\t\tminimum = 2\n\t\t\t\t\t\tif number and number < 0 then\n\t\t\t\t\t\t\tparms.opt_fraction_horizontal = true\n\t\t\t\t\t\t\tnumber = -number\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tminimum = 1\n\t\t\t\t\tend\n\t\t\t\t\tif number and is_integer and number >= minimum then\n\t\t\t\t\t\ten_value = number\n\t\t\t\t\telse\n\t\t\t\t\t\tadd_warning(parms, 1, (en_name == 'frac' and 'cvt_bad_frac' or 'cvt_bad_sigfig'), loc_value)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\ten_value = text_code.en_option_value[en_name][loc_value]\n\t\t\t\tif en_value == nil then\n\t\t\t\t\tif loc_value == '' then\n\t\t\t\t\t\tadd_warning(parms, 2, 'cvt_empty_option', loc_name)\n\t\t\t\t\telse\n\t\t\t\t\t\t-- loc_value can no longer be nil here (at one time, that could occur\n\t\t\t\t\t\t-- with aliases like |sing=off|adj=on), but am retaining safety check.\n\t\t\t\t\t\tlocal text = loc_value and (loc_name .. '=' .. loc_value) or loc_name\n\t\t\t\t\t\tadd_warning(parms, 1, 'cvt_unknown_option', text)\n\t\t\t\t\tend\n\t\t\t\telseif en_value == '' then\n\t\t\t\t\ten_value = nil  -- an ignored option like adj=off\n\t\t\t\telseif type(en_value) == 'string' and en_value:sub(1, 4) == 'opt_' then\n\t\t\t\t\tfor _, v in ipairs(split(en_value, ',')) do\n\t\t\t\t\t\tparms[v] = true\n\t\t\t\t\tend\n\t\t\t\t\ten_value = nil\n\t\t\t\tend\n\t\t\tend\n\t\t\tparms[en_name] = en_value\n\t\telse\n\t\t\tadd_warning(parms, 1, 'cvt_unknown_option', loc_name .. '=' .. loc_value)\n\t\tend\n\tend\n\tif parms.adj then\n\t\tif parms.adj:sub(1, 2) == 'ri' then\n\t\t\t-- It is known that adj is 'riN' where N is a single digit, so precision is valid.\n\t\t\t-- Only a single en digit is accepted.\n\t\t\tparms.input_precision = tonumber(parms.adj:sub(-1))\n\t\t\tparms.adj = nil\n\t\tend\n\tend\n\tlocal cfg_abbr = config.abbr\n\tif cfg_abbr then\n\t\tif cfg_abbr == 'on always' then\n\t\t\tparms.abbr = 'on'\n\t\telseif cfg_abbr == 'on default' then\n\t\t\tif parms.abbr == nil then\n\t\t\t\tparms.abbr = 'on'\n\t\t\tend\n\t\tend\n\tend\n\tif parms.abbr then\n\t\tparms.abbr_org = parms.abbr  -- original abbr that was set, before any flip\n\telseif parms.opt_hand_hh then\n\t\tparms.abbr_org = 'on'\n\t\tparms.abbr = 'on'\n\telse\n\t\tparms.abbr = 'out'  -- default is to abbreviate output only (use symbol, not name)\n\tend\n\tif parms.opt_flip then\n\t\tlocal function swap_in_out(option)\n\t\t\tlocal value = parms[option]\n\t\t\tif value == 'in' then\n\t\t\t\tparms[option] = 'out'\n\t\t\telseif value == 'out' then\n\t\t\t\tparms[option] = 'in'\n\t\t\tend\n\t\tend\n\t\tswap_in_out('abbr')\n\t\tswap_in_out('lk')\n\t\tif parms.opt_spell_in and not parms.opt_spell_out then\n\t\t\t-- For simplicity, and because it does not appear to be needed,\n\t\t\t-- user cannot set an option to spell the output only.\n\t\t\tparms.opt_spell_in = nil\n\t\t\tparms.opt_spell_out = true\n\t\tend\n\tend\n\tif parms.opt_spell_upper then\n\t\tparms.spell_upper = parms.opt_flip and 'out' or 'in'\n\tend\n\tif parms.opt_table or parms.opt_tablecen then\n\t\tif parms.abbr_org == nil and parms.lk == nil then\n\t\t\tparms.opt_values = true\n\t\tend\n\t\tlocal align = format('align=\"%s\"', parms.opt_table and 'right' or 'center')\n\t\tparms.table_joins = { align .. '|', '\\n|' .. align .. '|' }\n\tend\n\tif parms.opt_lang_en then\n\t\tfrom_en_table = nil\n\tend\n\treturn true\nend\n\nlocal function get_values(parms)\n\t-- If successful, update parms and return true, v, i where\n\t--   v = table of input values\n\t--   i = index to next entry in parms after those processed here\n\t-- or return false, t where t is an error message table.\n\tlocal ranges = text_code.ranges\n\tlocal valinfo = collection()  -- numbered table of input values\n\tlocal range = collection()  -- numbered table of range items (having, for example, 2 range items requires 3 input values)\n\tlocal had_nocomma  -- true if removed \"nocomma\" kludge from second parameter (like \"tonocomma\")\n\tlocal parm2 = strip(parms[2])\n\tif parm2 and parm2:sub(-7, -1) == 'nocomma' then\n\t\tparms[2] = strip(parm2:sub(1, -8))\n\t\tparms.opt_nocomma = true\n\t\thad_nocomma = true\n\tend\n\tlocal function extractor(i)\n\t\t-- If the parameter is not a value, try unpacking it as a range (\"1-23\" for \"1 to 23\").\n\t\t-- However, \"-1-2\/3\" is a negative fraction (-1⅔), so it must be extracted first.\n\t\t-- Unpacked items are inserted into the parms table.\n\t\tlocal valstr = strip(parms[i])  -- trim so any '-' as a negative sign will be at start\n\t\tlocal success, result = extract_number(parms, valstr, i > 1)\n\t\tif not success and valstr and i < 20 then  -- check i to limit abuse\n\t\t\tfor _, sep in ipairs(ranges.words) do\n\t\t\t\tlocal start, stop = valstr:find(sep, 2, true)  -- start at 2 to skip any negative sign for range '-'\n\t\t\t\tif start then\n\t\t\t\t\tparms[i] = valstr:sub(stop + 1)\n\t\t\t\t\ttable.insert(parms, i, sep)\n\t\t\t\t\ttable.insert(parms, i, valstr:sub(1, start - 1))\n\t\t\t\t\treturn extractor(i)  -- this allows combinations like \"1 x 2 to 3 x 4\"\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn success, result\n\tend\n\tlocal i = 1\n\tlocal is_change\n\twhile true do\n\t\tlocal success, info = extractor(i)  -- need to set parms.opt_nocomma before calling this\n\t\tif not success then return false, info end\n\t\ti = i + 1\n\t\tif is_change then\n\t\t\tinfo.is_change = true  -- value is after \"±\" and so is a change (significant for range like ",{"type":"{{","value":[["convert"],["5"],["±"],["5"],["°C"]]},")\n\t\t\tis_change = nil\n\t\tend\n\t\tvalinfo:add(info)\n\t\tlocal next = strip(parms[i])\n\t\tlocal range_item = ranges.types[next] or ranges.types[ranges.aliases[next]]\n\t\tif not range_item then\n\t\t\tbreak\n\t\tend\n\t\ti = i + 1\n\t\trange:add(range_item)\n\t\tif type(range_item) == 'table' then\n\t\t\tparms.is_range_x = range_item.is_range_x\n\t\t\tis_change = range_item.is_range_change\n\t\tend\n\tend\n\tif range.n > 0 then\n\t\tif range.n > 30 then  -- limit abuse, although 4 is a more likely upper limit\n\t\t\treturn false, { 'cvt_invalid_num' }  -- misleading message but it will do\n\t\tend\n\t\tparms.range = range\n\telseif had_nocomma then\n\t\treturn false, { 'cvt_unknown', parm2 }\n\tend\n\treturn true, valinfo, i\nend\n\nlocal function simple_get_values(parms)\n\t-- If input is like \"",{"type":"{{","value":[["convert"],["valid_value"],["valid_unit"],["..."]]},"\",\n\t-- return true, v, 3, in_unit, in_unit_table\n\t-- (as for get_values(), but with a unit name and table for a valid unit;\n\t-- 3 = index in parms of whatever follows valid_unit, if anything).\n\t-- The valid_value is not negative and does not use a fraction, and\n\t-- no options requiring further processing of the input are used.\n\t-- Otherwise, return nothing and caller will reparse the input.\n\t-- Testing shows this function is successful for 96% of converts in articles,\n\t-- and that on average it speeds up converts by 8%.\n\tif parms.input_precision or parms.opt_spell_in then return end\n\tlocal clean = to_en(strip(parms[1] or ''))\n\tif #clean > 10 or not clean:match('^[0-9.]+$') then return end\n\tlocal value = tonumber(clean)\n\tif not value then return end\n\tlocal info = {\n\t\tvalue = value,\n\t\taltvalue = value,\n\t\tsingular = (value == 1),\n\t\tclean = clean,\n\t\tshow = with_separator(parms, clean),\n\t}\n\tlocal in_unit = strip(parms[2])\n\tlocal success, in_unit_table = lookup(in_unit, parms.opt_sp_us, 'no_combination')\n\tif not success then return end\n\treturn true, { info }, 3, in_unit, in_unit_table\nend\n\nlocal function get_parms(pframe)\n\t-- If successful, return true, parms, unit where\n\t--   parms is a table of all arguments passed to the template\n\t--        converted to named arguments, and\n\t--   unit is the input unit table;\n\t-- or return false, t where t is an error message table.\n\t-- The returned input unit table may be for a fake unit using the specified\n\t-- unit code as the symbol and name, and with bad_mcode = message code table.\n\t-- MediaWiki removes leading and trailing whitespace from the values of\n\t-- named arguments. However, the values of numbered arguments include any\n\t-- whitespace entered in the template, and whitespace is used by some\n\t-- parameters (example: the numbered parameters associated with \"disp=x\").\n\tlocal parms = {}  -- arguments passed to template, after translation\n\tlocal kv_pairs = {}  -- table of input key:value pairs where key is a name; needed because cannot iterate parms and add new fields to it\n\tfor k, v in pairs(pframe.args) do\n\t\tif type(k) == 'number' or k == 'test' then  -- parameter \"test\" is reserved for testing and is not translated\n\t\t\tparms[k] = v\n\t\telse\n\t\t\tkv_pairs[k] = v\n\t\tend\n\tend\n\tlocal success, msg = translate_parms(parms, kv_pairs)\n\tif not success then return false, msg end\n\tlocal success, valinfo, i, in_unit, in_unit_table = simple_get_values(parms)\n\tif not success then\n\t\tsuccess, valinfo, i = get_values(parms)\n\t\tif not success then return false, valinfo end\n\t\tin_unit = strip(parms[i])\n\t\ti = i + 1\n\t\tsuccess, in_unit_table = lookup(in_unit, parms.opt_sp_us, 'no_combination')\n\t\tif not success then\n\t\t\tif in_unit == nil then\n\t\t\t\tin_unit = ''\n\t\t\tend\n\t\t\tif parms.opt_ignore_error then  -- display given unit code with no error (for use with ",{"type":"{{","value":[["val"]]},")\n\t\t\t\tin_unit_table = nil\n\t\t\tend\n\t\t\tin_unit_table = setmetatable({ symbol = in_unit, name2 = in_unit, utype = \"length\", scale = 1, bad_mcode = in_unit_table, default = \"m\" }, unit_mt)\n\t\tend\n\tend\n\tif parms.test == 'msg' then\n\t\t-- Am testing the messages produced when no output unit is specified, and\n\t\t-- the input unit has a missing or invalid default.\n\t\t-- Set two units for testing that.\n\t\t-- LATER: Remove this code.\n\t\tif in_unit == 'chain' then\n\t\t\tin_unit_table.default = nil  -- no default\n\t\telseif in_unit == 'rd' then\n\t\t\tin_unit_table.default  = \"ft!X!m\"  -- an invalid expression\n\t\tend\n\tend\n\tin_unit_table.valinfo = valinfo\n\tin_unit_table.inout = 'in'  -- this is an input unit\n\tif not parms.range then\n\t\tlocal success, inext, composite_unit = get_composite(parms, i, valinfo[1].value, in_unit_table)\n\t\tif not success then return false, inext end\n\t\tif composite_unit then\n\t\t\tin_unit_table = composite_unit\n\t\t\ti = inext\n\t\tend\n\tend\n\tif in_unit_table.builtin == 'mach' then\n\t\t-- As with old template, a number following Mach as the input unit is the altitude,\n\t\t-- and there is no way to specify an altitude for the output unit.\n\t\t-- Could put more code in this function to get any output unit and check for\n\t\t-- an altitude following that unit.\n\t\tlocal success, info = extract_number(parms, parms[i], false, true)\n\t\tif success then\n\t\t\ti = i + 1\n\t\t\tin_unit_table.altitude = info.value\n\t\tend\n\tend\n\tlocal next = strip(parms[i])\n\ti = i + 1\n\tlocal precision, is_bad_precision\n\tlocal function set_precision(text)\n\t\tlocal number, is_integer = get_number(text)\n\t\tif number then\n\t\t\tif is_integer then\n\t\t\t\tprecision = number\n\t\t\telse\n\t\t\t\tprecision = text\n\t\t\t\tis_bad_precision = true\n\t\t\tend\n\t\t\treturn true  -- text was used for precision, good or bad\n\t\tend\n\tend\n\tif not set_precision(next) then\n\t\tparms.out_unit = next\n\t\tif set_precision(strip(parms[i])) then\n\t\t\ti = i + 1\n\t\tend\n\tend\n\tif parms.opt_adj_mid then\n\t\tparms.opt_adjectival = true\n\t\tnext = parms[i]\n\t\ti = i + 1\n\t\tif next then  -- mid-text words\n\t\t\tif next:sub(1, 1) == '-' then\n\t\t\t\tparms.mid = next\n\t\t\telse\n\t\t\t\tparms.mid = ' ' .. next\n\t\t\tend\n\t\tend\n\tend\n\tif parms.opt_one_preunit then\n\t\tparms[parms.opt_flip and 'preunit2' or 'preunit1'] = preunits(1, parms[i])\n\t\ti = i + 1\n\tend\n\tif parms.disp == 'x' then\n\t\t-- Following is reasonably compatible with the old template.\n\t\tlocal first = parms[i] or ''\n\t\tlocal second = parms[i+1] or ''\n\t\ti = i + 2\n\t\tif strip(first) == '' then  -- user can enter ' ' rather than ' ' to avoid the default\n\t\t\tfirst = ' [ ' .. first\n\t\t\tsecond = ' ]' .. second\n\t\tend\n\t\tparms.joins = { first, second }\n\telseif parms.opt_two_preunits then\n\t\tlocal p1, p2 = preunits(2, parms[i], parms[i+1])\n\t\ti = i + 2\n\t\tif parms.preunit1 then\n\t\t\t-- To simplify documentation, allow unlikely use of adj=pre with disp=preunit\n\t\t\t-- (however, an output unit must be specified with adj=pre and with disp=preunit).\n\t\t\tparms.preunit1 = parms.preunit1 .. p1\n\t\t\tparms.preunit2 = p2\n\t\telse\n\t\t\tparms.preunit1, parms.preunit2 = p1, p2\n\t\tend\n\tend\n\tif precision == nil then\n\t\tif set_precision(strip(parms[i])) then\n\t\t\ti = i + 1\n\t\tend\n\tend\n\tif is_bad_precision then\n\t\tadd_warning(parms, 1, 'cvt_bad_prec', precision)\n\telse\n\t\tparms.precision = precision\n\tend\n\treturn true, parms, in_unit_table\nend\n\nlocal function record_default_precision(parms, out_current, precision)\n\t-- If necessary, adjust parameters and return a possibly adjusted precision.\n\t-- When converting a range of values where a default precision is required,\n\t-- that default is calculated for each value because the result sometimes\n\t-- depends on the precise input and output values. This function may cause\n\t-- the entire convert process to be repeated in order to ensure that the\n\t-- same default precision is used for each individual convert.\n\t-- If that were not done, a range like 1000 to 1000.4 may give poor results\n\t-- because the first output could be heavily rounded, while the second is not.\n\t-- For range 1000.4 to 1000, this function can give the second convert the\n\t-- same default precision that was used for the first.\n\tif not parms.opt_round_each then\n\t\tlocal maxdef = out_current.max_default_precision\n\t\tif maxdef then\n\t\t\tif maxdef < precision then\n\t\t\t\tparms.do_convert_again = true\n\t\t\t\tout_current.max_default_precision = precision\n\t\t\telse\n\t\t\t\tprecision = out_current.max_default_precision\n\t\t\tend\n\t\telse\n\t\t\tout_current.max_default_precision = precision\n\t\tend\n\tend\n\treturn precision\nend\n\nlocal function default_precision(parms, invalue, inclean, denominator, outvalue, in_current, out_current, extra)\n\t-- Return a default value for precision (an integer like 2, 0, -2).\n\t-- If denominator is not nil, it is the value of the denominator in inclean.\n\t-- Code follows procedures used in old template.\n\tlocal fudge = 1e-14  -- ",{"type":"{{","value":[["Order of magnitude"]]}," adds this, so we do too\n\tlocal prec, minprec, adjust\n\tlocal utype = out_current.utype\n\tlocal subunit_ignore_trailing_zero\n\tlocal subunit_more_precision  -- kludge for \"in\" used in input like \"|2|ft|6|in\"\n\tlocal composite = in_current.composite\n\tif composite then\n\t\tsubunit_ignore_trailing_zero = true  -- input \"|2|st|10|lb\" has precision 0, not -1\n\t\tif composite",{"type":"[","value":["#composite"]},".exception == 'subunit_more_precision' then\n\t\t\tsubunit_more_precision = true  -- do not use standard precision with input like \"|2|ft|6|in\"\n\t\tend\n\tend\n\tif denominator and denominator > 0 then\n\t\tprec = math.max(log10(denominator), 1)\n\telse\n\t\t-- Count digits after decimal mark, handling cases like '12.345e6'.\n\t\tlocal exponent\n\t\tlocal integer, dot, decimals, expstr = inclean:match('^(%d*)(%.?)(%d*)(.*)')\n\t\tlocal e = expstr:sub(1, 1)\n\t\tif e == 'e' or e == 'E' then\n\t\t\texponent = tonumber(expstr:sub(2))\n\t\tend\n\t\tif dot == '' then\n\t\t\tprec = subunit_ignore_trailing_zero and 0 or -integer:match('0*$'):len()\n\t\telse\n\t\t\tprec = #decimals\n\t\tend\n\t\tif exponent then\n\t\t\t-- So '1230' and '1.23e3' both give prec = -1, and '0.00123' and '1.23e-3' give 5.\n\t\t\tprec = prec - exponent\n\t\tend\n\tend\n\tif in_current.istemperature and out_current.istemperature then\n\t\t-- Converting between common temperatures (°C, °F, °R, K); not keVT, MK.\n\t\t-- Kelvin value can be almost zero, or small but negative due to precision problems.\n\t\t-- Also, an input value like -300 C (below absolute zero) gives negative kelvins.\n\t\t-- Calculate minimum precision from absolute value.\n\t\tadjust = 0\n\t\tlocal kelvin = abs((invalue - in_current.offset) * in_current.scale)\n\t\tif kelvin < 1e-8 then  -- assume nonzero due to input or calculation precision problem\n\t\t\tminprec = 2\n\t\telse\n\t\t\tminprec = 2 - floor(log10(kelvin) + fudge)  -- 3 sigfigs in kelvin\n\t\tend\n\telse\n\t\tif invalue == 0 or outvalue <= 0 then\n\t\t\t-- We are never called with a negative outvalue, but it might be zero.\n\t\t\t-- This is special-cased to avoid calculation exceptions.\n\t\t\treturn record_default_precision(parms, out_current, 0)\n\t\tend\n\t\tif out_current.exception == 'integer_more_precision' and floor(invalue) == invalue then\n\t\t\t-- With certain output units that sometimes give poor results\n\t\t\t-- with default rounding, use more precision when the input\n\t\t\t-- value is equal to an integer. An example of a poor result\n\t\t\t-- is when input 50 gives a smaller output than input 49.5.\n\t\t\t-- Experiment shows this helps, but it does not eliminate all\n\t\t\t-- surprises because it is not clear whether \"50\" should be\n\t\t\t-- interpreted as \"from 45 to 55\" or \"from 49.5 to 50.5\".\n\t\t\tadjust = -log10(in_current.scale)\n\t\telseif subunit_more_precision then\n\t\t\t-- Conversion like \"",{"type":"{{","value":[["convert"],["6"],["ft"],["1"],["in"],["cm"]]},"\" (where subunit is \"in\")\n\t\t\t-- has a non-standard adjust value, to give more output precision.\n\t\t\tadjust = log10(out_current.scale) + 2\n\t\telse\n\t\t\tadjust = log10(abs(invalue \/ outvalue))\n\t\tend\n\t\tadjust = adjust + log10(2)\n\t\t-- Ensure that the output has at least two significant figures.\n\t\tminprec = 1 - floor(log10(outvalue) + fudge)\n\tend\n\tif extra then\n\t\tadjust = extra.adjust or adjust\n\t\tminprec = extra.minprec or minprec\n\tend\n\treturn record_default_precision(parms, out_current, math.max(floor(prec + adjust), minprec))\nend\n\nlocal function convert(parms, invalue, info, in_current, out_current)\n\t-- Convert given input value from one unit to another.\n\t-- Return output_value (a number) if a simple convert, or\n\t-- return f, t where\n\t--   f = true, t = table of information with results, or\n\t--   f = false, t = error message table.\n\tlocal inscale = in_current.scale\n\tlocal outscale = out_current.scale\n\tif not in_current.iscomplex and not out_current.iscomplex then\n\t\treturn invalue * (inscale \/ outscale)  -- minimize overhead for most common case\n\tend\n\tif in_current.invert or out_current.invert then\n\t\t-- Inverted units, such as inverse length, inverse time, or\n\t\t-- fuel efficiency. Built-in units do not have invert set.\n\t\tif (in_current.invert or 1) * (out_current.invert or 1) < 0 then\n\t\t\treturn 1 \/ (invalue * inscale * outscale)\n\t\tend\n\t\treturn invalue * (inscale \/ outscale)\n\telseif in_current.offset then\n\t\t-- Temperature (there are no built-ins for this type of unit).\n\t\tif info.is_change then\n\t\t\treturn invalue * (inscale \/ outscale)\n\t\tend\n\t\treturn (invalue - in_current.offset) * (inscale \/ outscale) + out_current.offset\n\telse\n\t\t-- Built-in unit.\n\t\tlocal in_builtin = in_current.builtin\n\t\tlocal out_builtin = out_current.builtin\n\t\tif in_builtin and out_builtin then\n\t\t\tif in_builtin == out_builtin then\n\t\t\t\treturn invalue\n\t\t\tend\n\t\t\t-- There are no cases (yet) where need to convert from one\n\t\t\t-- built-in unit to another, so this should never occur.\n\t\t\treturn false, { 'cvt_bug_convert' }\n\t\tend\n\t\tif in_builtin == 'mach' or out_builtin == 'mach' then\n\t\t\tlocal adjust\n\t\t\tif in_builtin == 'mach' then\n\t\t\t\tinscale = speed_of_sound(in_current.altitude)\n\t\t\t\tadjust = outscale \/ 0.1\n\t\t\telse\n\t\t\t\toutscale = speed_of_sound(out_current.altitude)\n\t\t\t\tadjust = 0.1 \/ inscale\n\t\t\tend\n\t\t\treturn true, {\n\t\t\t\toutvalue = invalue * (inscale \/ outscale),\n\t\t\t\tadjust = log10(adjust) + log10(2),\n\t\t\t}\n\t\telseif in_builtin == 'hand' then\n\t\t\t-- 1 hand = 4 inches; 1.2 hands = 6 inches.\n\t\t\t-- Decimals of a hand are only defined for the first digit, and\n\t\t\t-- the first fractional digit should be a number of inches (1, 2 or 3).\n\t\t\t-- However, this code interprets the entire fractional part as the number\n\t\t\t-- of inches \/ 10 (so 1.75 inches would be 0.175 hands).\n\t\t\t-- A value like 12.3 hands is exactly 12*4 + 3 inches; base default precision on that.\n\t\t\tlocal integer, fracpart = math.modf(invalue)\n\t\t\tlocal inch_value = 4 * integer + 10 * fracpart  -- equivalent number of inches\n\t\t\tlocal factor = inscale \/ outscale\n\t\t\tif factor == 4 then\n\t\t\t\t-- Am converting to inches: show exact result, and use \"inches\" not \"in\" by default.\n\t\t\t\tif parms.abbr_org == nil then\n\t\t\t\t\tout_current.usename = true\n\t\t\t\tend\n\t\t\t\tlocal show = format('%g', abs(inch_value))  -- show and clean are unsigned\n\t\t\t\tif not show:find('e', 1, true) then\n\t\t\t\t\treturn true, {\n\t\t\t\t\t\tinvalue = inch_value,\n\t\t\t\t\t\toutvalue = inch_value,\n\t\t\t\t\t\tclean = show,\n\t\t\t\t\t\tshow = show,\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal outvalue = (integer + 2.5 * fracpart) * factor\n\t\t\tlocal fracstr = info.clean:match('%.(.*)') or ''\n\t\t\tlocal fmt\n\t\t\tif fracstr == '' then\n\t\t\t\tfmt = '%.0f'\n\t\t\telse\n\t\t\t\tfmt = '%.' .. format('%d', #fracstr - 1) .. 'f'\n\t\t\tend\n\t\t\treturn true, {\n\t\t\t\tinvalue = inch_value,\n\t\t\t\tclean = format(fmt, inch_value),\n\t\t\t\toutvalue = outvalue,\n\t\t\t\tminprec = 0,\n\t\t\t}\n\t\tend\n\tend\n\treturn false, { 'cvt_bug_convert' }  -- should never occur\nend\n\nlocal cvt_to_hand\n\nlocal function cvtround(parms, info, in_current, out_current)\n\t-- Return true, t where t is a table with the conversion results; fields:\n\t--   show = rounded, formatted string with the result of converting value in info,\n\t--      using the rounding specified in parms.\n\t--   singular = true if result is positive, and (after rounding)\n\t--      is \"1\", or like \"1.00\";\n\t--   (and more fields shown below, and a calculated 'absvalue' field).\n\t-- or return true, nil if no value specified;\n\t-- or return false, t where t is an error message table.\n\t-- Input info.clean uses en digits (it has been translated, if necessary).\n\t-- Output show uses en or non-en digits as appropriate, or can be spelled.\n\tlocal invalue\n\tif info then\n\t\tinvalue = info.value\n\t\tif in_current.builtin == 'hand' then\n\t\t\tinvalue = info.altvalue\n\t\tend\n\tend\n\tif invalue == nil or invalue == '' then\n\t\treturn true, nil\n\tend\n\tif out_current.builtin == 'hand' then\n\t\treturn cvt_to_hand(parms, info, in_current, out_current)\n\tend\n\tlocal outvalue, extra = convert(parms, invalue, info, in_current, out_current)\n\tif extra then\n\t\tif not outvalue then return false, extra end\n\t\tinvalue = extra.invalue or invalue\n\t\toutvalue = extra.outvalue\n\tend\n\tif not valid_number(outvalue) then\n\t\treturn false, { 'cvt_invalid_num' }\n\tend\n\tlocal isnegative\n\tif outvalue < 0 then\n\t\tisnegative = true\n\t\toutvalue = -outvalue\n\tend\n\tlocal numerator, precision, success, show, exponent\n\tlocal denominator = out_current.frac\n\tif denominator then\n\t\tshow = fraction_table(outvalue, denominator)\n\telse\n\t\tprecision = parms.precision\n\t\tif not precision then\n\t\t\tlocal sigfig = parms.sigfig\n\t\t\tif sigfig then\n\t\t\t\tshow, exponent = make_sigfig(outvalue, sigfig)\n\t\t\telseif parms.opt_round5 or parms.opt_round25  then\n\t\t\t\tlocal n = parms.opt_round5 and 5 or 25\n\t\t\t\tshow = format('%.0f', floor((outvalue \/ n) + 0.5) * n)\n\t\t\telse\n\t\t\t\tlocal inclean = info.clean\n\t\t\t\tif extra then\n\t\t\t\t\tinclean = extra.clean or inclean\n\t\t\t\t\tshow = extra.show\n\t\t\t\tend\n\t\t\t\tif not show then\n\t\t\t\t\tprecision = default_precision(parms, invalue, inclean, info.denominator, outvalue, in_current, out_current, extra)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tif precision then\n\t\tif precision >= 0 then\n\t\t\tlocal fudge\n\t\t\tif precision <= 8 then\n\t\t\t\t-- Add a fudge to handle common cases of bad rounding due to inability\n\t\t\t\t-- to precisely represent some values. This makes the following work:\n\t\t\t\t-- ",{"type":"{{","value":[["convert"],["-100.1"],["C"],["K"]]}," and ",{"type":"{{","value":[["convert"],["5555000"],["um"],["m"],["2"]]},".\n\t\t\t\t-- Old template uses #expr round, which invokes PHP round().\n\t\t\t\t-- LATER: Investigate how PHP round() works.\n\t\t\t\tfudge = 2e-14\n\t\t\telse\n\t\t\t\tfudge = 0\n\t\t\tend\n\t\t\tlocal fmt = '%.' .. format('%d', precision) .. 'f'\n\t\t\tlocal success\n\t\t\tsuccess, show = pcall(format, fmt, outvalue + fudge)\n\t\t\tif not success then\n\t\t\t\treturn false, { 'cvt_big_prec', tostring(precision) }\n\t\t\tend\n\t\telse\n\t\t\tprecision = -precision  -- #digits to zero (in addition to any digits after dot)\n\t\t\tlocal shift = 10 ^ precision\n\t\t\tshow = format('%.0f', outvalue\/shift)\n\t\t\tif show ~= '0' then\n\t\t\t\texponent = #show + precision\n\t\t\tend\n\t\tend\n\tend\n\tlocal t = format_number(parms, show, exponent, isnegative)\n\t-- Set singular using match because on some systems 0.99999999999999999 is 1.0.\n\tt.singular = (type(show) == 'string' and (show == '1' or show:match('^1%.0*$') ~= nil) and not isnegative)\n\tt.fraction_table = (type(show) == 'table') and show or nil\n\tt.raw_absvalue = outvalue  -- absolute value before rounding\n\treturn true, setmetatable(t, {\n\t\t__index = function (self, key)\n\t\t\tif key == 'absvalue' then\n\t\t\t\t-- Calculate absolute value after rounding, if needed.\n\t\t\t\tlocal clean, exponent = rawget(self, 'clean'), rawget(self, 'exponent')\n\t\t\t\tlocal value = tonumber(clean)  -- absolute value (any negative sign has been ignored)\n\t\t\t\tif exponent then\n\t\t\t\t\tvalue = value * 10^exponent\n\t\t\t\tend\n\t\t\t\trawset(self, key, value)\n\t\t\t\treturn value\n\t\t\tend\n\t\tend })\nend\n\nfunction cvt_to_hand(parms, info, in_current, out_current)\n\t-- Convert input to hands, inches.\n\t-- Return true, t where t is a table with the conversion results;\n\t-- or return false, t where t is an error message table.\n\tif parms.abbr_org == nil then\n\t\tout_current.usename = true  -- default is to show name not symbol\n\tend\n\tlocal precision = parms.precision\n\tlocal frac = out_current.frac\n\tif not frac and precision and precision > 1 then\n\t\tfrac = (precision == 2) and 2 or 4\n\tend\n\tlocal out_next = out_current.out_next\n\tif out_next then\n\t\t-- Use magic knowledge to determine whether the next unit is inches without requiring i18n.\n\t\t-- The following ensures that when the output combination \"hand in\" is used, the inches\n\t\t-- value is rounded to match the hands value. Also, displaying say \"61½\" instead of 61.5\n\t\t-- is better as 61.5 implies the value is not 61.4.\n\t\tif out_next.exception == 'subunit_more_precision' then\n\t\t\tout_next.frac = frac\n\t\tend\n\tend\n\t-- Convert to inches; calculate hands from that.\n\tlocal dummy_unit_table = { scale = out_current.scale \/ 4, frac = frac }\n\tlocal success, outinfo = cvtround(parms, info, in_current, dummy_unit_table)\n\tif not success then return false, outinfo end\n\tlocal tfrac = outinfo.fraction_table\n\tlocal inches = outinfo.raw_absvalue\n\tif tfrac then\n\t\tinches = floor(inches)  -- integer part only; fraction added later\n\telse\n\t\tinches = floor(inches + 0.5)  -- a hands measurement never shows decimals of an inch\n\tend\n\tlocal hands, inches = divide(inches, 4)\n\toutinfo.absvalue = hands + inches\/4  -- supposed to be the absolute rounded value, but this is close enough\n\tlocal inchstr = tostring(inches)  -- '0', '1', '2' or '3'\n\tif precision and precision <= 0 then  -- using negative or 0 for precision rounds to nearest hand\n\t\thands = floor(outinfo.raw_absvalue\/4 + 0.5)\n\t\tinchstr = ''\n\telseif tfrac then\n\t\t-- Always show an integer before fraction (like \"15.0½\") because \"15½\" means 15-and-a-half hands.\n\t\tinchstr = numdot .. format_fraction(parms, 'out', false, inchstr, tfrac.numstr, tfrac.denstr)\n\telse\n\t\tinchstr = numdot .. from_en(inchstr)\n\tend\n\toutinfo.show = outinfo.sign .. with_separator(parms, format('%.0f', hands)) .. inchstr\n\treturn true, outinfo\nend\n\nlocal function evaluate_condition(value, condition)\n\t-- Return true or false from applying a conditional expression to value,\n\t-- or throw an error if invalid.\n\t-- A very limited set of expressions is supported:\n\t--    v < 9\n\t--    v * 9 < 9\n\t-- where\n\t--    'v' is replaced with value\n\t--    9 is any number (as defined by Lua tonumber)\n\t--      only en digits are accepted\n\t--    '<' can also be '<=' or '>' or '>='\n\t-- In addition, the following form is supported:\n\t--    LHS and RHS\n\t-- where\n\t--    LHS, RHS = any of above expressions.\n\tlocal function compare(value, text)\n\t\tlocal arithop, factor, compop, limit = text:match('^%s*v%s*([*]?)(.-)([<>]=?)(.*)$')\n\t\tif arithop == nil then\n\t\t\terror('Invalid default expression', 0)\n\t\telseif arithop == '*' then\n\t\t\tfactor = tonumber(factor)\n\t\t\tif factor == nil then\n\t\t\t\terror('Invalid default expression', 0)\n\t\t\tend\n\t\t\tvalue = value * factor\n\t\tend\n\t\tlimit = tonumber(limit)\n\t\tif limit == nil then\n\t\t\terror('Invalid default expression', 0)\n\t\tend\n\t\tif compop == '<' then\n\t\t\treturn value < limit\n\t\telseif compop == '<=' then\n\t\t\treturn value <= limit\n\t\telseif compop == '>' then\n\t\t\treturn value > limit\n\t\telseif compop == '>=' then\n\t\t\treturn value >= limit\n\t\tend\n\t\terror('Invalid default expression', 0)  -- should not occur\n\tend\n\tlocal lhs, rhs = condition:match('^(.-%W)and(%W.*)')\n\tif lhs == nil then\n\t\treturn compare(value, condition)\n\tend\n\treturn compare(value, lhs) and compare(value, rhs)\nend\n\nlocal function get_default(value, unit_table)\n\t-- Return true, s where s = name of unit's default output unit,\n\t-- or return false, t where t is an error message table.\n\t-- Some units have a default that depends on the input value\n\t-- (the first value if a range of values is used).\n\t-- If '!' is in the default, the first bang-delimited field is an\n\t-- expression that uses 'v' to represent the input value.\n\t-- Example: 'v < 120 ! small ! big ! suffix' (suffix is optional)\n\t-- evaluates 'v < 120' as a boolean with result\n\t-- 'smallsuffix' if (value < 120), or 'bigsuffix' otherwise.\n\t-- Input must use en digits and '.' decimal mark.\n\tlocal default = default_exceptions[unit_table.defkey or unit_table.symbol] or unit_table.default\n\tif not default then\n\t\treturn false, { 'cvt_no_default', unit_table.symbol }\n\tend\n\tif default:find('!', 1, true) == nil then\n\t\treturn true, default\n\tend\n\tlocal t = split(default, '!')\n\tif #t == 3 or #t == 4 then\n\t\tlocal success, result = pcall(evaluate_condition, value, t[1])\n\t\tif success then\n\t\t\tdefault = result and t[2] or t[3]\n\t\t\tif #t == 4 then\n\t\t\t\tdefault = default .. t[4]\n\t\t\tend\n\t\t\treturn true, default\n\t\tend\n\tend\n\treturn false, { 'cvt_bad_default', unit_table.symbol }\nend\n\nlocal linked_pages  -- to record linked pages so will not link to the same page more than once\n\nlocal function make_link(link, id, link_key)\n\t-- Return wikilink \"",{"type":"[[","value":[["link"],["id"]]},"\", possibly abbreviated as in examples:\n\t--   ",{"type":"[[","value":[["Mile"],["mile"]]},"  --> ",{"type":"[[","value":[["mile"]]},"\n\t--   ",{"type":"[[","value":[["Mile"],["miles"]]}," --> ",{"type":"[[","value":[["mile"]]},"s\n\t-- However, just id is returned if:\n\t-- * no link given (so caller does not need to check if a link was defined); or\n\t-- * link has previously been used during the current convert (to avoid overlinking).\n\t-- Linking with a unit uses the unit table as the link key, which fails to detect\n\t-- overlinking for conversions like the following (each links \"mile\" twice):\n\t--   ",{"type":"{{","value":[["convert"],["1"],["impgal\/mi"],["USgal\/mi"],["lk=on"]]},"\n\t--   ",{"type":"{{","value":[["convert"],["1"],["l\/km"],["impgal\/mi USgal\/mi"],["lk=on"]]},"\n\tlink_key = link_key or link  -- use key if given (the key, but not the link, may be known when need to cancel a link record)\n\tif not link or link == '' or linked_pages[link_key] then\n\t\treturn id\n\tend\n\tlinked_pages[link_key] = true\n\t-- Following only works for language en, but it should be safe on other wikis,\n\t-- and overhead of doing it generally does not seem worthwhile.\n\tlocal l = link:sub(1, 1):lower() .. link:sub(2)\n\tif link == id or l == id then\n\t\treturn '",{"type":"[[","value":[["' .. id .. '"]]},"'\n\telseif link .. 's' == id or l .. 's' == id then\n\t\treturn '",{"type":"[[","value":[["' .. id:sub(1, -2) .. '"]]},"s'\n\telse\n\t\treturn '",{"type":"[[","value":[["' .. link .. '"],["' .. id .. '"]]},"'\n\tend\nend\n\nlocal function variable_name(clean, unit_table)\n\t-- For sl.wiki (Slovenian Wikipedia), a unit name depends on the value.\n\t-- Parameter clean is the unsigned rounded value in en digits, as a string.\n\t-- Value             Source    Example for \"m\"\n\t-- integer 1:        name1     meter  (also is the name of the unit)\n\t-- integer 2:        var{1}    metra\n\t-- integer 3 and 4:  var{2}    metri\n\t-- integer else:     var{3}    metrov (0 and 5 or more)\n\t-- real\/fraction:    var{4}    metra\n\t-- var{i} means the i'th field in unit_table.varname if it exists and has\n\t-- an i'th field, otherwise name2.\n\t-- Fields are separated with \"!\" and are not empty.\n\t-- A field for a unit using an SI prefix has the prefix name inserted,\n\t-- replacing '#' if found, or before the field otherwise.\n\tlocal vname\n\tif clean == '1' then\n\t\tvname = unit_table.name1\n\telseif unit_table.varname then\n\t\tlocal i\n\t\tif clean == '2' then\n\t\t\ti = 1\n\t\telseif clean == '3' or clean == '4' then\n\t\t\ti = 2\n\t\telseif clean:find('.', 1, true) then\n\t\t\ti = 4\n\t\telse\n\t\t\ti = 3\n\t\tend\n\t\tvname = split(unit_table.varname, '!')[i]\n\tend\n\tif vname then\n\t\tlocal si_name = rawget(unit_table, 'si_name') or ''\n\t\tlocal pos = vname:find('#', 1, true)\n\t\tif pos then\n\t\t\tvname = vname:sub(1, pos - 1) .. si_name .. vname:sub(pos + 1)\n\t\telse\n\t\t\tvname = si_name .. vname\n\t\tend\n\t\treturn vname\n\tend\n\treturn unit_table.name2\nend\n\nlocal function linked_id(unit_table, key_id, want_link, clean)\n\t-- Return final unit id (symbol or name), optionally with a wikilink,\n\t-- and update unit_table.sep if required.\n\t-- key_id is one of: 'symbol', 'sym_us', 'name1', 'name1_us', 'name2', 'name2_us'.\n\tlocal abbr_on = (key_id == 'symbol' or key_id == 'sym_us')\n\tif abbr_on and want_link then\n\t\tlocal symlink = rawget(unit_table, 'symlink')\n\t\tif symlink then\n\t\t\treturn symlink  -- for exceptions that have the linked symbol built-in\n\t\tend\n\tend\n\tlocal multiplier = rawget(unit_table, 'multiplier')\n\tlocal per = unit_table.per\n\tif per then\n\t\tlocal unit1 = per[1]  -- top unit_table, or nil\n\t\tlocal unit2 = per[2]  -- bottom unit_table\n\t\tif abbr_on then\n\t\t\tif not unit1 then\n\t\t\t\tunit_table.sep = ''  -- no separator in \"$2\/acre\"\n\t\t\tend\n\t\t\tif not want_link then\n\t\t\t\tlocal symbol = unit_table.symbol_raw\n\t\t\t\tif symbol then\n\t\t\t\t\treturn symbol  -- for exceptions that have the symbol built-in\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tlocal key_id2  -- unit2 is always singular\n\t\tif key_id == 'name2' then\n\t\t\tkey_id2 = 'name1'\n\t\telseif key_id == 'name2_us' then\n\t\t\tkey_id2 = 'name1_us'\n\t\telse\n\t\t\tkey_id2 = key_id\n\t\tend\n\t\tlocal result\n\t\tif abbr_on then\n\t\t\tresult = '\/'\n\t\telseif unit1 then\n\t\t\tresult = ' ' .. per_word .. ' '\n\t\telse\n\t\t\tresult = per_word .. ' '\n\t\tend\n\t\tif want_link and unit_table.link then\n\t\t\tif abbr_on or not varname then\n\t\t\t\tresult = (unit1 and unit1[key_id] or '') .. result .. unit2[key_id2]\n\t\t\telse\n\t\t\t\tresult = (unit1 and variable_name(clean, unit1) or '') .. result .. variable_name('1', unit2)\n\t\t\tend\n\t\t\treturn make_link(unit_table.link, result, unit_table)\n\t\tend\n\t\tif unit1 then\n\t\t\tresult = linked_id(unit1, key_id, want_link, clean) .. result\n\t\tend\n\t\treturn result .. linked_id(unit2, key_id2, want_link, '1')\n\tend\n\tif multiplier then\n\t\t-- A multiplier (like \"100\" in \"100km\") forces the unit to be plural.\n\t\tmultiplier = from_en(multiplier)\n\t\tif abbr_on then\n\t\t\tmultiplier = multiplier .. ' '\n\t\telse\n\t\t\tmultiplier = multiplier .. ' '\n\t\t\tif key_id == 'name1' then\n\t\t\t\tkey_id = 'name2'\n\t\t\telseif key_id == 'name1_us' then\n\t\t\t\tkey_id = 'name2_us'\n\t\t\tend\n\t\tend\n\telse\n\t\tmultiplier = ''\n\tend\n\tlocal id = unit_table.fixed_name or ((varname and not abbr_on) and variable_name(clean, unit_table) or unit_table[key_id])\n\tif want_link then\n\t\tlocal link = link_exceptions[unit_table.linkey or unit_table.symbol] or unit_table.link\n\t\tif link then\n\t\t\tlocal before = ''\n\t\t\tlocal i = unit_table.customary\n\t\t\tif i == 1 and unit_table.sp_us then\n\t\t\t\ti = 2  -- show \"U.S.\" not \"US\"\n\t\t\tend\n\t\t\tif i == 3 and abbr_on then\n\t\t\t\ti = 4  -- abbreviate \"imperial\" to \"imp\"\n\t\t\tend\n\t\t\tlocal customary = text_code.customary_units[i]\n\t\t\tif customary then\n\t\t\t\t-- LATER: This works for language en only, but it's esoteric so ignore for now.\n\t\t\t\tlocal pertext\n\t\t\t\tif id:sub(1, 1) == '\/' then\n\t\t\t\t\t-- Want unit \"\/USgal\" to display as \"\/U.S. gal\", not \"U.S. \/gal\".\n\t\t\t\t\tpertext = '\/'\n\t\t\t\t\tid = id:sub(2)\n\t\t\t\telseif id:sub(1, 4) == 'per ' then\n\t\t\t\t\t-- Similarly want \"per U.S. gallon\", not \"U.S. per gallon\" (but in practice this is unlikely to be used).\n\t\t\t\t\tpertext = 'per '\n\t\t\t\t\tid = id:sub(5)\n\t\t\t\telse\n\t\t\t\t\tpertext = ''\n\t\t\t\tend\n\t\t\t\t-- Omit any \"US\"\/\"U.S.\"\/\"imp\"\/\"imperial\" from start of id since that will be inserted.\n\t\t\t\tlocal removes = (i < 3) and { 'US ', 'US ', 'U.S. ', 'U.S. ' } or { 'imp ', 'imp ', 'imperial ' }\n\t\t\t\tfor _, prefix in ipairs(removes) do\n\t\t\t\t\tlocal plen = #prefix\n\t\t\t\t\tif id:sub(1, plen) == prefix then\n\t\t\t\t\t\tid = id:sub(plen + 1)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tbefore = pertext .. make_link(customary.link, customary[1]) .. ' '\n\t\t\tend\n\t\t\tid = before .. make_link(link, id, unit_table)\n\t\tend\n\tend\n\treturn multiplier .. id\nend\n\nlocal function make_id(parms, which, unit_table)\n\t-- Return id, f where\n\t--   id = unit name or symbol, possibly modified\n\t--   f = true if id is a name, or false if id is a symbol\n\t-- using 1st or 2nd values (which), and for 'in' or 'out' (unit_table.inout).\n\t-- Result is '' if no symbol\/name is to be used.\n\t-- In addition, set unit_table.sep = ' ' or ' ' or ''\n\t-- (the separator that caller will normally insert before the id).\n\tif parms.opt_values then\n\t\tunit_table.sep = ''\n\t\treturn ''\n\tend\n\tlocal inout = unit_table.inout\n\tlocal info = unit_table.valinfo[which]\n\tlocal abbr_org = parms.abbr_org\n\tlocal adjectival = parms.opt_adjectival\n\tlocal disp = parms.disp\n\tlocal lk = parms.lk\n\tlocal want_link = (lk == 'on' or lk == inout)\n\tlocal usename = unit_table.usename\n\tlocal singular = info.singular\n\tif usename then\n\t\t-- Old template does something like this.\n\t\tif want_link then\n\t\t\t-- A linked unit uses the standard singular.\n\t\telse\n\t\t\t-- Set non-standard singular.\n\t\t\tlocal flipped = parms.opt_flip\n\t\t\tif inout == 'in' then\n\t\t\t\tif not adjectival and (abbr_org == 'out' or flipped) then\n\t\t\t\t\tlocal value = info.value\n\t\t\t\t\tsingular = (0 < value and value < 1.0001)\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif (abbr_org == 'on') or\n\t\t\t\t(not flipped and (abbr_org == nil or abbr_org == 'out')) or\n\t\t\t\t(flipped and abbr_org == 'in') then\n\t\t\t\t\tsingular = (info.absvalue < 1.0001 and\n\t\t\t\t\t\t\t\tnot info.is_scientific)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tlocal want_name\n\tif usename then\n\t\twant_name = true\n\telse\n\t\tif abbr_org == nil then\n\t\t\tif disp == 'br' or disp == 'or' or disp == 'slash' then\n\t\t\t\twant_name = true\n\t\t\tend\n\t\t\tif unit_table.usesymbol then\n\t\t\t\twant_name = false\n\t\t\tend\n\t\tend\n\t\tif want_name == nil then\n\t\t\tlocal abbr = parms.abbr\n\t\t\tif abbr == 'on' or abbr == inout or (abbr == 'mos' and inout == 'out') then\n\t\t\t\twant_name = false\n\t\t\telse\n\t\t\t\twant_name = true\n\t\t\tend\n\t\tend\n\tend\n\tlocal key\n\tif want_name then\n\t\tif lk == nil and unit_table.builtin == 'hand' then\n\t\t\twant_link = true\n\t\tend\n\t\tif parms.opt_use_nbsp then\n\t\t\tunit_table.sep = ' '\n\t\telse\n\t\t\tunit_table.sep = ' '\n\t\tend\n\t\tif parms.opt_singular then\n\t\t\tlocal value\n\t\t\tif inout == 'in' then\n\t\t\t\tvalue = info.value\n\t\t\telse\n\t\t\t\tvalue = info.absvalue\n\t\t\tend\n\t\t\tif value then  -- some unusual units do not always set value field\n\t\t\t\tvalue = abs(value)\n\t\t\t\tsingular = (0 < value and value < 1.0001)\n\t\t\tend\n\t\tend\n\t\tif unit_table.engscale or parms.is_range_x then\n\t\t\t-- engscale: so \"|1|e3kg\" gives \"1 thousand kilograms\" (plural)\n\t\t\t-- is_range_x: so \"|0.5|x|0.9|mi\" gives \"0.5 by 0.9 miles\" (plural)\n\t\t\tsingular = false\n\t\tend\n\t\tkey = (adjectival or singular) and 'name1' or 'name2'\n\t\tif unit_table.sp_us then\n\t\t\tkey = key .. '_us'\n\t\tend\n\telse\n\t\tif unit_table.builtin == 'hand' then\n\t\t\tif parms.opt_hand_hh then\n\t\t\t\tunit_table.symbol = 'hh'  -- LATER: might want i18n applied to this\n\t\t\tend\n\t\tend\n\t\tunit_table.sep = ' '\n\t\tkey = unit_table.sp_us and 'sym_us' or 'symbol'\n\tend\n\treturn linked_id(unit_table, key, want_link, info.clean), want_name\nend\n\nlocal function decorate_value(parms, unit_table, which)\n\t-- If needed, update unit_table so values will be shown with extra information.\n\t-- For consistency with the old template (but different from fmtpower),\n\t-- the style to display powers of 10 includes \"display:none\" to allow some\n\t-- browsers to copy, for example, \"10³\" as \"10^3\", rather than as \"103\".\n\tlocal info\n\tlocal engscale = unit_table.engscale\n\tlocal prefix = unit_table.vprefix\n\tif engscale or prefix then\n\t\tinfo = unit_table.valinfo[which]\n\t\tif info.decorated then\n\t\t\treturn  -- do not redecorate if repeating convert\n\t\tend\n\t\tinfo.decorated = true\n\tend\n\tif engscale then\n\t\tlocal inout = unit_table.inout\n\t\tlocal abbr = parms.abbr\n\t\tif abbr == 'on' or abbr == inout then\n\t\t\tinfo.show = info.show ..\n\t\t\t\t'",{"type":"<","value":["span",{"style":"margin-left:0.2em"},["×",{"type":"<","value":["span",{"style":"margin-left:0.1em"},["' ..\n\t\t\t\tfrom_en('10') ..\n\t\t\t\t'"]]}]]},{"type":"<","value":["s",{"style":"display:none"},["^"]]},{"type":"<","value":["sup",["' ..\n\t\t\t\tfrom_en(tostring(engscale.exponent)) .. '"]]},"'\n\t\telse\n\t\t\tlocal number_id\n\t\t\tlocal lk = parms.lk\n\t\t\tif lk == 'on' or lk == inout then\n\t\t\t\tnumber_id = make_link(engscale.link, engscale[1])\n\t\t\telse\n\t\t\t\tnumber_id = engscale[1]\n\t\t\tend\n\t\t\t-- WP:NUMERAL recommends \" \" in values like \"12 million\".\n\t\t\tinfo.show = info.show .. (parms.opt_adjectival and '-' or ' ') .. number_id\n\t\tend\n\tend\n\tif prefix then\n\t\tinfo.show = prefix .. info.show\n\tend\nend\n\nlocal function process_input(parms, in_current)\n\t-- Processing required once per conversion.\n\t-- Return block of text to represent input (value\/unit).\n\tif parms.opt_output_only or parms.opt_output_number_only or parms.opt_output_unit_only then\n\t\tparms.joins = { ",{"type":"''","value":[", "]}," }\n\t\treturn ''\n\tend\n\tlocal first_unit\n\tlocal composite = in_current.composite  -- nil or table of units\n\tif composite then\n\t\tfirst_unit = composite[1]\n\telse\n\t\tfirst_unit = in_current\n\tend\n\tlocal id1, want_name = make_id(parms, 1, first_unit)\n\tlocal sep = first_unit.sep  -- separator between value and unit, set by make_id\n\tlocal preunit = parms.preunit1\n\tif preunit then\n\t\tsep = ''  -- any separator is included in preunit\n\telse\n\t\tpreunit = ''\n\tend\n\tif parms.opt_input_unit_only then\n\t\tparms.joins = { ",{"type":"''","value":[", "]}," }\n\t\tif composite then\n\t\t\tlocal parts = { id1 }\n\t\t\tfor i, unit in ipairs(composite) do\n\t\t\t\tif i > 1 then\n\t\t\t\t\ttable.insert(parts, (make_id(parms, 1, unit)))\n\t\t\t\tend\n\t\t\tend\n\t\t\tid1 = table.concat(parts, ' ')\n\t\tend\n\t\tif want_name and parms.opt_adjectival then\n\t\t\treturn preunit .. hyphenated(id1)\n\t\tend\n\t\treturn  preunit .. id1\n\tend\n\tlocal disp_joins = text_code.disp_joins\n\tlocal abbr = parms.abbr\n\tlocal disp = parms.disp\n\tif disp == nil then  -- special case for the most common setting\n\t\tparms.joins = disp_joins['b']\n\telseif disp ~= 'x' then\n\t\t-- Old template does this.\n\t\tif disp == 'slash' then\n\t\t\tif parms.abbr_org == nil then\n\t\t\t\tdisp = 'slash-nbsp'\n\t\t\telseif abbr == 'in' or abbr == 'out' then\n\t\t\t\tdisp = 'slash-sp'\n\t\t\telse\n\t\t\t\tdisp = 'slash-nosp'\n\t\t\tend\n\t\telseif disp == 'sqbr' then\n\t\t\tif abbr == 'on' then\n\t\t\t\tdisp = 'sqbr-nbsp'\n\t\t\telse\n\t\t\t\tdisp = 'sqbr-sp'\n\t\t\tend\n\t\tend\n\t\tparms.joins = disp_joins[disp] or disp_joins['b']\n\tend\n\tif parms.opt_also_symbol and not composite then\n\t\tlocal join1 = parms.joins[1]\n\t\tif join1 == ' (' or join1 == ' [' then\n\t\t\tparms.joins = { join1 .. first_unit[first_unit.sp_us and 'sym_us' or 'symbol'] .. ', ', parms.joins[2] }\n\t\tend\n\tend\n\tif in_current.builtin == 'mach' then\n\t\tlocal prefix = id1 .. ' '\n\t\tlocal range = parms.range\n\t\tlocal valinfo = first_unit.valinfo\n\t\tlocal result = prefix .. valinfo[1].show\n\t\tif range then\n\t\t\t-- For simplicity and because more not needed, handle one range item only.\n\t\t\tlocal prefix2 = make_id(parms, 2, first_unit) .. ' '\n\t\t\tresult = range_text(range[1], want_name, parms, result, prefix2 .. valinfo[2].show)\n\t\tend\n\t\treturn preunit .. result\n\tend\n\tif composite then\n\t\t-- Simplify: assume there is no range, and no decoration.\n\t\tlocal mid = ''\n\t\tlocal sep1 = ' '\n\t\tlocal sep2 = ' '\n\t\tif parms.opt_adjectival then\n\t\t\tif not parms.opt_flip then\n\t\t\t\tmid = parms.mid or ''\n\t\t\tend\n\t\t\tif want_name then\n\t\t\t\tsep1 = '-'\n\t\t\t\tsep2 = '-'\n\t\t\tend\n\t\tend\n\t\tlocal parts = { first_unit.valinfo[1].show .. sep1 .. id1 }\n\t\tfor i, unit in ipairs(composite) do\n\t\t\tif i > 1 then\n\t\t\t\ttable.insert(parts, unit.valinfo[1].show .. sep1 .. (make_id(parms, 1, unit)))\n\t\t\tend\n\t\tend\n\t\treturn table.concat(parts, sep2) .. mid\n\tend\n\tlocal result, mos\n\tlocal range = parms.range\n\tif range then\n\t\tmos = (abbr == 'mos')\n\t\tif not (mos or (parms.is_range_x and not want_name)) then\n\t\t\tlinked_pages[first_unit] = nil  -- so the second and only id will be linked, if wanted\n\t\tend\n\tend\n\tlocal id = (range == nil) and id1 or make_id(parms, 2, first_unit)\n\tlocal extra, was_hyphenated = hyphenated_maybe(parms, want_name, sep, id, 'in')\n\tif mos and was_hyphenated then\n\t\tmos = false  -- suppress repeat of unit in a range\n\t\tif linked_pages[first_unit] then\n\t\t\tlinked_pages[first_unit] = nil\n\t\t\tid = make_id(parms, 2, first_unit)\n\t\t\textra = hyphenated_maybe(parms, want_name, sep, id, 'in')\n\t\tend\n\tend\n\tlocal valinfo = first_unit.valinfo\n\tif range then\n\t\tif range.n == 1 then\n\t\t\t-- Like ",{"type":"{{","value":[["convert"],["1"],["x"],["2"],["ft"]]}," (one range item; two values).\n\t\t\t-- Do what old template did.\n\t\t\tlocal sep1 = first_unit.sep\n\t\t\tif mos then\n\t\t\t\tdecorate_value(parms, in_current, 1)\n\t\t\t\tdecorate_value(parms, in_current, 2)\n\t\t\t\tresult = valinfo[1].show .. sep1 .. id1\n\t\t\telseif parms.is_range_x and not want_name then\n\t\t\t\tif abbr == 'in' or abbr == 'on' then\n\t\t\t\t\tdecorate_value(parms, in_current, 1)\n\t\t\t\tend\n\t\t\t\tdecorate_value(parms, in_current, 2)\n\t\t\t\tresult = valinfo[1].show .. sep1 .. id1\n\t\t\telse\n\t\t\t\tif abbr == 'in' or abbr == 'on' then\n\t\t\t\t\tdecorate_value(parms, in_current, 1)\n\t\t\t\tend\n\t\t\t\tdecorate_value(parms, in_current, 2)\n\t\t\t\tresult = valinfo[1].show\n\t\t\tend\n\t\t\tresult = range_text(range[1], want_name, parms, result, valinfo[2].show)\n\t\telse\n\t\t\t-- Like ",{"type":"{{","value":[["convert"],["1"],["x"],["2"],["x"],["3"],["ft"]]}," (two or more range items): simplify.\n\t\t\tdecorate_value(parms, in_current, 1)\n\t\t\tresult = valinfo[1].show\n\t\t\tfor i = 1, range.n do\n\t\t\t\tdecorate_value(parms, in_current, i+1)\n\t\t\t\tresult = range_text(range[i], want_name, parms, result, valinfo[i+1].show)\n\t\t\tend\n\t\tend\n\telse\n\t\tdecorate_value(parms, first_unit, 1)\n\t\tresult = valinfo[1].show\n\tend\n\treturn result .. preunit .. extra\nend\n\nlocal function process_one_output(parms, out_current)\n\t-- Processing required for each output unit.\n\t-- Return block of text to represent output (value\/unit).\n\tlocal id1, want_name = make_id(parms, 1, out_current)\n\tlocal sep = out_current.sep  -- set by make_id\n\tlocal preunit = parms.preunit2\n\tif preunit then\n\t\tsep = ''  -- any separator is included in preunit\n\telse\n\t\tpreunit = ''\n\tend\n\tif parms.opt_output_unit_only then\n\t\tif want_name and parms.opt_adjectival then\n\t\t\treturn preunit .. hyphenated(id1)\n\t\tend\n\t\treturn preunit .. id1\n\tend\n\tif out_current.builtin == 'mach' then\n\t\tlocal prefix = id1 .. ' '\n\t\tlocal range = parms.range\n\t\tlocal valinfo = out_current.valinfo\n\t\tlocal result = prefix .. valinfo[1].show\n\t\tif range then\n\t\t\t-- For simplicity and because more not needed, handle one range item only.\n\t\t\tresult = range_text(range[1], want_name, parms, result, prefix .. valinfo[2].show)\n\t\tend\n\t\treturn preunit .. result\n\tend\n\tlocal result\n\tlocal range = parms.range\n\tif range then\n\t\tif not (parms.is_range_x and not want_name) then\n\t\t\tlinked_pages[out_current] = nil  -- so the second and only id will be linked, if wanted\n\t\tend\n\tend\n\tlocal id = (range == nil) and id1 or make_id(parms, 2, out_current)\n\tlocal extra = hyphenated_maybe(parms, want_name, sep, id, 'out')\n\tlocal valinfo = out_current.valinfo\n\tif range then\n\t\tif range.n == 1 then\n\t\t\tlocal sep1 = out_current.sep\n\t\t\tlocal abbr = parms.abbr\n\t\t\tif parms.is_range_x and not want_name then\n\t\t\t\tif abbr == 'out' or abbr == 'on' then\n\t\t\t\t\tdecorate_value(parms, out_current, 1)\n\t\t\t\tend\n\t\t\t\tdecorate_value(parms, out_current, 2)\n\t\t\t\tresult = valinfo[1].show .. sep1 .. id1\n\t\t\telse\n\t\t\t\tif abbr == 'out' or abbr == 'on' then\n\t\t\t\t\tdecorate_value(parms, out_current, 1)\n\t\t\t\tend\n\t\t\t\tdecorate_value(parms, out_current, 2)\n\t\t\t\tresult = valinfo[1].show\n\t\t\tend\n\t\t\tresult = range_text(range[1], want_name, parms, result, valinfo[2].show)\n\t\telse\n\t\t\t-- Like ",{"type":"{{","value":[["convert"],["1"],["x"],["2"],["x"],["3"],["ft"]]}," (two or more range items): simplify.\n\t\t\tdecorate_value(parms, out_current, 1)\n\t\t\tresult = valinfo[1].show\n\t\t\tfor i = 1, range.n do\n\t\t\t\tdecorate_value(parms, out_current, i+1)\n\t\t\t\tresult = range_text(range[i], want_name, parms, result, valinfo[i+1].show)\n\t\t\tend\n\t\tend\n\telse\n\t\tdecorate_value(parms, out_current, 1)\n\t\tresult = valinfo[1].show\n\tend\n\tif parms.opt_output_number_only then\n\t\treturn result\n\tend\n\treturn result .. preunit .. extra\nend\n\nlocal function make_output_single(parms, in_unit_table, out_unit_table)\n\t-- Return true, item where item = wikitext of the conversion result\n\t-- for a single output (which is not a combination or a multiple);\n\t-- or return false, t where t is an error message table.\n\tout_unit_table.valinfo = collection()\n\tlocal range = parms.range\n\tfor i = 1, (range and (range.n + 1) or 1) do\n\t\tlocal success, info = cvtround(parms, in_unit_table.valinfo[i], in_unit_table, out_unit_table)\n\t\tif not success then return false, info end\n\t\tout_unit_table.valinfo:add(info)\n\tend\n\treturn true, process_one_output(parms, out_unit_table)\nend\n\nlocal function make_output_multiple(parms, in_unit_table, out_unit_table)\n\t-- Return true, item where item = wikitext of the conversion result\n\t-- for an output which is a multiple (like 'ftin');\n\t-- or return false, t where t is an error message table.\n\tlocal multiple = out_unit_table.multiple  -- table of scaling factors (will not be nil)\n\tlocal combos = out_unit_table.combination  -- table of unit tables (will not be nil)\n\tlocal abbr = parms.abbr\n\tlocal abbr_org = parms.abbr_org\n\tlocal disp = parms.disp\n\tlocal want_name = (abbr_org == nil and (disp == 'or' or disp == 'slash')) or\n\t\t\t\t\t\tnot (abbr == 'on' or abbr == 'out' or abbr == 'mos')\n\tlocal want_link = (parms.lk == 'on' or parms.lk == 'out')\n\tlocal mid = ''\n\tlocal sep1 = ' '\n\tlocal sep2 = ' '\n\tif parms.opt_adjectival then\n\t\tif parms.opt_flip then\n\t\t\tmid = parms.mid or ''\n\t\tend\n\t\tif want_name then\n\t\t\tsep1 = '-'\n\t\t\tsep2 = '-'\n\t\tend\n\tend\n\tlocal do_spell = parms.opt_spell_out\n\tparms.opt_spell_out = nil  -- so the call to cvtround does not spell the value\n\tlocal function make_result(info, isfirst)\n\t\tlocal fmt, outvalue, sign\n\t\tlocal results = {}\n\t\tfor i = 1, #combos do\n\t\t\tlocal tfrac, thisvalue, strforce\n\t\t\tlocal out_current = combos[i]\n\t\t\tout_current.inout = 'out'\n\t\t\tlocal scale = multiple[i]\n\t\t\tif i == 1 then  -- least significant unit ('in' from 'ftin')\n\t\t\t\tlocal decimals\n\t\t\t\tout_current.frac = out_unit_table.frac\n\t\t\t\tlocal success, outinfo = cvtround(parms, info, in_unit_table, out_current)\n\t\t\t\tif not success then return false, outinfo end\n\t\t\t\tif isfirst then\n\t\t\t\t\tout_unit_table.valinfo = { outinfo }  -- in case output value of first least significant unit is needed\n\t\t\t\tend\n\t\t\t\tsign = outinfo.sign\n\t\t\t\ttfrac = outinfo.fraction_table\n\t\t\t\tif outinfo.is_scientific then\n\t\t\t\t\tstrforce = outinfo.show\n\t\t\t\t\tdecimals = ''\n\t\t\t\telseif tfrac then\n\t\t\t\t\tdecimals = ''\n\t\t\t\telse\n\t\t\t\t\tdecimals = (outinfo.show):match('[' .. numdot .. '](.*)') or ''  -- outinfo.show is in local language\n\t\t\t\tend\n\t\t\t\tfmt = '%.' .. ulen(decimals) .. 'f'  -- to reproduce precision\n\t\t\t\tif decimals == '' then\n\t\t\t\t\tif tfrac then\n\t\t\t\t\t\toutvalue = floor(outinfo.raw_absvalue)  -- integer part only; fraction added later\n\t\t\t\t\telse\n\t\t\t\t\t\toutvalue = floor(outinfo.raw_absvalue + 0.5)  -- keep all integer digits of least significant unit\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\toutvalue = outinfo.absvalue\n\t\t\t\tend\n\t\t\tend\n\t\t\tif scale then\n\t\t\t\toutvalue, thisvalue = divide(outvalue, scale)\n\t\t\telse\n\t\t\t\tthisvalue = outvalue\n\t\t\tend\n\t\t\tlocal id\n\t\t\tif want_name then\n\t\t\t\tif varname then\n\t\t\t\t\tlocal clean\n\t\t\t\t\tif strforce or tfrac then\n\t\t\t\t\t\tclean = '.1'  -- dummy value to force name for floating point\n\t\t\t\t\telse\n\t\t\t\t\t\tclean = format(fmt, thisvalue)\n\t\t\t\t\tend\n\t\t\t\t\tid = variable_name(clean, out_current)\n\t\t\t\telse\n\t\t\t\t\tid = out_current[(thisvalue == 1) and 'name1' or 'name2']\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tid = out_current['symbol']\n\t\t\tend\n\t\t\tif want_link then\n\t\t\t\tlocal link = out_current.link\n\t\t\t\tif link then\n\t\t\t\t\tid = make_link(link, id, out_current)\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal strval\n\t\t\tlocal inout = (i == #combos or outvalue == 0) and 'out' or ''  -- trick so the last value processed (first displayed) has uppercase, if requested\n\t\t\tif strforce and outvalue == 0 then\n\t\t\t\tsign = ''  -- any sign is in strforce\n\t\t\t\tstrval = strforce  -- show small values in scientific notation; will only use least significant unit\n\t\t\telseif tfrac then\n\t\t\t\tlocal wholestr = (thisvalue > 0) and tostring(thisvalue) or nil\n\t\t\t\tstrval = format_fraction(parms, inout, false, wholestr, tfrac.numstr, tfrac.denstr, do_spell)\n\t\t\telse\n\t\t\t\tstrval = (thisvalue == 0) and from_en('0') or with_separator(parms, format(fmt, thisvalue))\n\t\t\t\tif do_spell then\n\t\t\t\t\tstrval = spell_number(parms, inout, strval) or strval\n\t\t\t\tend\n\t\t\tend\n\t\t\ttable.insert(results, strval .. sep1 .. id)\n\t\t\tif outvalue == 0 then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tfmt = '%.0f'  -- only least significant unit can have a non-integral value\n\t\tend\n\t\tlocal reversed, count = {}, #results\n\t\tfor i = 1, count do\n\t\t\treversed[i] = results[count + 1 - i]\n\t\tend\n\t\treturn true, sign .. table.concat(reversed, sep2)\n\tend\n\tlocal valinfo = in_unit_table.valinfo\n\tlocal success, result = make_result(valinfo[1], true)\n\tif not success then return false, result end\n\tlocal range = parms.range\n\tif range then\n\t\tfor i = 1, range.n do\n\t\t\tlocal success, result2 = make_result(valinfo[i+1])\n\t\t\tif not success then return false, result2 end\n\t\t\tresult = range_text(range[i], want_name, parms, result, result2)\n\t\tend\n\tend\n\treturn true, result .. mid\nend\n\nlocal function process(parms, in_unit_table, out_unit_table)\n\t-- Return true, s where s = final wikitext result,\n\t-- or return false, t where t is an error message table.\n\tlinked_pages = {}\n\tlocal success, bad_output, out_first\n\tlocal bad_input_mcode = in_unit_table.bad_mcode  -- false if input unit is valid\n\tlocal invalue1 = in_unit_table.valinfo[1].value\n\tlocal out_unit = parms.out_unit\n\tif out_unit == nil or out_unit == '' then\n\t\tif bad_input_mcode then\n\t\t\tbad_output = ''\n\t\telse\n\t\t\tsuccess, out_unit = get_default(invalue1, in_unit_table)\n\t\t\tparms.out_unit = out_unit\n\t\t\tif not success then\n\t\t\t\tbad_output = out_unit\n\t\t\tend\n\t\tend\n\tend\n\tif not bad_output and not out_unit_table then\n\t\tsuccess, out_unit_table = lookup(out_unit, parms.opt_sp_us, 'any_combination')\n\t\tif success then\n\t\t\tlocal mismatch = check_mismatch(in_unit_table, out_unit_table)\n\t\t\tif mismatch then\n\t\t\t\tbad_output = mismatch\n\t\t\tend\n\t\telse\n\t\t\tbad_output = out_unit_table\n\t\tend\n\tend\n\tlocal flipped = parms.opt_flip and not bad_input_mcode\n\tlocal parts = {}\n\tfor part = 1, 2 do\n\t\t-- The LHS (parts[1]) is normally the input, but is the output if flipped.\n\t\t-- Process LHS first so it will be linked, if wanted.\n\t\t-- Linking to the same item is suppressed in the RHS to avoid overlinking.\n\t\tif (part == 1 and not flipped) or (part == 2 and flipped) then\n\t\t\tparts[part] = process_input(parms, in_unit_table)\n\t\telseif bad_output then\n\t\t\tif bad_output ~= '' then\n\t\t\t\tparts[part] = message(bad_output)\n\t\t\tend\n\t\telse\n\t\t\tlocal outputs = {}\n\t\t\tlocal combos  -- nil (for 'ft' or 'ftin'), or table of unit tables (for 'm ft')\n\t\t\tif not out_unit_table.multiple then  -- nil\/false ('ft' or 'm ft'), or table of factors ('ftin')\n\t\t\t\tcombos = out_unit_table.combination\n\t\t\tend\n\t\t\tlocal frac = parms.frac  -- nil or denominator of fraction for output values\n\t\t\tif frac then\n\t\t\t\t-- Apply fraction to the unit (if only one), or to non-SI units (if a combination),\n\t\t\t\t-- except that if a precision is also specified, the fraction only applies to\n\t\t\t\t-- the hand unit; that allows the following result:\n\t\t\t\t-- ",{"type":"{{","value":[["convert"],["156"],["cm"],["in hand"],["1"],["frac=2"]]}," → 156 centimetres (61.4 in; 15.1½ hands)\n\t\t\t\t-- However, the following is handled elsewhere as a special case:\n\t\t\t\t-- ",{"type":"{{","value":[["convert"],["156"],["cm"],["hand in"],["1"],["frac=2"]]}," → 156 centimetres (15.1½ hands; 61½ in)\n\t\t\t\tif combos then\n\t\t\t\t\tlocal precision = parms.precision\n\t\t\t\t\tfor _, unit in ipairs(combos) do\n\t\t\t\t\t\tif unit.builtin == 'hand' or (not precision and not unit.prefixes) then\n\t\t\t\t\t\t\tunit.frac = frac\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tout_unit_table.frac = frac\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal imax = combos and #combos or 1  -- 1 (single unit) or number of unit tables\n\t\t\tfor i = 1, imax do\n\t\t\t\tlocal success, item\n\t\t\t\tlocal out_current = combos and combos[i] or out_unit_table\n\t\t\t\tout_current.inout = 'out'\n\t\t\t\tif i == 1 then\n\t\t\t\t\tout_first = out_current\n\t\t\t\t\tif imax > 1 and out_current.builtin == 'hand' then\n\t\t\t\t\t\tout_current.out_next = combos[2]  -- built-in hand can influence next unit in a combination\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif out_current.multiple then\n\t\t\t\t\tsuccess, item = make_output_multiple(parms, in_unit_table, out_current)\n\t\t\t\telse\n\t\t\t\t\tsuccess, item = make_output_single(parms, in_unit_table, out_current)\n\t\t\t\tend\n\t\t\t\tif not success then return false, item end\n\t\t\t\ttable.insert(outputs, item)\n\t\t\tend\n\t\t\tlocal sep = parms.table_joins and parms.table_joins[2] or '; '\n\t\t\tparts[part] = parms.opt_input_unit_only and '' or table.concat(outputs, sep)\n\t\tend\n\tend\n\tif parms.opt_sortable_in or parms.opt_sortable_out then\n\t\tlocal value\n\t\tif parms.opt_sortable_in then\n\t\t\tvalue = invalue1\n\t\telse\n\t\t\tlocal info = out_first and out_first.valinfo\n\t\t\tif info then\n\t\t\t\tinfo = info[1]\n\t\t\t\tvalue = info.raw_absvalue\n\t\t\t\tif value and info.sign == MINUS then\n\t\t\t\t\tvalue = -value\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tparts[1] = ntsh((value or 0), parms.opt_sortable_debug) .. parts[1]\n\tend\n\tlocal wikitext\n\tif bad_input_mcode then\n\t\twikitext = parts[1] .. message(bad_input_mcode)\n\telseif parms.table_joins then\n\t\twikitext = parms.table_joins[1] .. parts[1] .. parms.table_joins[2] .. parts[2]\n\telse\n\t\twikitext = parts[1] .. parms.joins[1] .. parts[2] .. parms.joins[2]\n\tend\n\tif parms.warnings and not bad_input_mcode then\n\t\twikitext = wikitext .. parms.warnings\n\tend\n\treturn true, wikitext, out_unit_table\nend\n\nlocal function main_convert(frame)\n\t-- Do convert, and if needed, do it again with higher default precision.\n\tset_config(frame)\n\tlocal result, out_unit_table\n\tlocal success, parms, in_unit_table = get_parms(frame:getParent())\n\tif success then\n\t\tfor i = 1, 2 do  -- use counter so cannot get stuck repeating convert\n\t\t\tsuccess, result, out_unit_table = process(parms, in_unit_table, out_unit_table)\n\t\t\tif success and parms.do_convert_again then\n\t\t\t\tparms.do_convert_again = false\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\telse\n\t\tresult = parms\n\tend\n\tif success then\n\t\treturn result\n\tend\n\treturn message(result)\nend\n\nreturn { convert = main_convert }"]